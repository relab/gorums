package encoding

import (
	"fmt"
	"testing"

	ordering "github.com/relab/gorums/ordering"
	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
)

// This test file benchmarks different ways to encode a data message (of unknown type) and metadata.
// The easiest way to implement this is to marshal the data message and embed it in the metadata message.
// However, this is not performant when the data message size is large. A more performant solution is to
// embed the data message as a field in the metadata message. However, this requires that the Protobuf
// definitions are generated by the Gorums plugin such that the types can be known. This is difficult to
// automate, and would likely require the user to run protoc twice. A third solution is to use
// `UnknownFields` to embed the metadata message within the data message. The problem with this solution
// is that the message type must be identified in some way, as the metadata cannot be read before the
// data message has been unmarshaled.
//
// Currently, Gorums uses the first approach, and embeds the data message in the metadata message.
// This approach is benchmarked by `BenchmarkMetadataWithEmbeddedMessage`.
// The second approach that makes the data message a field in the metadata message is benchmarked by
// `BenchmarkMessageAsField`.
// The third approach that uses `UnknownFields` is benchmarked by `BenchmarkMetadataAsUnknownField`.

func addMetadata(message *Message, metadata *Metadata) error {
	md, err := proto.Marshal(metadata)
	if err != nil {
		return err
	}
	b := protowire.AppendTag(nil, 20000, protowire.BytesType)
	b = protowire.AppendBytes(b, md)
	unknown := message.ProtoReflect().GetUnknown()
	unknown = append(b, unknown...)
	message.ProtoReflect().SetUnknown(unknown)
	return nil
}

func decodeMetadata(message *Message) (*Metadata, error) {
	unknown := message.ProtoReflect().GetUnknown()
	num, typ, i := protowire.ConsumeTag(unknown)
	if num != 20000 || typ != protowire.BytesType {
		return nil, fmt.Errorf("Metadata incorrectly formatted or not present")
	}
	unknown = unknown[i:]
	md, i := protowire.ConsumeBytes(unknown)
	unknown = unknown[i:]
	metadata := new(Metadata)
	err := proto.Unmarshal(md, metadata)
	if err != nil {
		return nil, err
	}
	message.ProtoReflect().SetUnknown(unknown)
	return metadata, nil
}

func TestAddMetadata(t *testing.T) {
	msg := &Message{Data: "Hello world"}
	md := &Metadata{ID: 1}

	err := addMetadata(msg, md)

	if err != nil {
		t.Error(err)
	}
}

func TestDecodeMetadata(t *testing.T) {
	msg := &Message{Data: "Hello world"}
	md := &Metadata{ID: 1}
	err := addMetadata(msg, md)
	if err != nil {
		t.Error(err)
	}

	_md, err := decodeMetadata(msg)
	if err != nil {
		t.Error(err)
	}

	if _md.ID != md.ID {
		t.Error("IDs don't match!")
	}
}

func TestEndToEnd(t *testing.T) {
	msg := &Message{Data: "Hello world"}
	md := &Metadata{ID: 1}
	err := addMetadata(msg, md)
	if err != nil {
		t.Error(err)
	}

	b, err := proto.Marshal(msg)
	if err != nil {
		t.Error(err)
	}

	_msg := new(Message)
	err = proto.Unmarshal(b, _msg)
	if err != nil {
		t.Error(err)
	}

	_md, err := decodeMetadata(_msg)
	if err != nil {
		t.Error(err)
	}
	if _md.ID != md.ID {
		t.Error("IDs don't match!")
	}
}

var benchmarks = []int{10, 100, 1000, 10000, 100000}

func BenchmarkMetadataAsUnknownField(b *testing.B) {
	b.Run("Marshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				b.StopTimer()
				payload := make([]byte, bm)
				b.StartTimer()
				for i := 0; i < b.N; i++ {
					msg := &Message{Data: "Hello world", Payload: payload}
					md := &Metadata{ID: 1}
					err := addMetadata(msg, md)
					if err != nil {
						b.Error(err)
					}

					_, err = proto.Marshal(msg)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
	b.Run("Unmarshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				var buf []byte
				{
					b.StopTimer()
					var err error
					payload := make([]byte, bm)
					msg := &Message{Data: "Hello world", Payload: payload}

					md := &Metadata{ID: 1}
					err = addMetadata(msg, md)
					if err != nil {
						b.Error(err)
					}

					buf, err = proto.Marshal(msg)
					if err != nil {
						b.Error(err)
					}
					b.StartTimer()
				}
				for i := 0; i < b.N; i++ {
					msg := new(Message)
					err := proto.Unmarshal(buf, msg)
					if err != nil {
						b.Error(err)
					}
					_, err = decodeMetadata(msg)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
}

func BenchmarkMetadataWithEmbeddedMessage(b *testing.B) {
	b.Run("Marshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				b.StopTimer()
				payload := make([]byte, bm)
				b.StartTimer()
				for i := 0; i < b.N; i++ {
					msg := &Message{Data: "Hello world", Payload: payload}
					buf, err := proto.Marshal(msg)
					if err != nil {
						b.Error(err)
					}

					md := &Metadata{ID: 1, Embed: &Metadata_Data{buf}}

					_, err = proto.Marshal(md)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				var buf []byte
				{
					b.StopTimer()
					var err error
					payload := make([]byte, bm)
					msg := &Message{Data: "Hello world", Payload: payload}
					buf, err = proto.Marshal(msg)
					if err != nil {
						b.Error(err)
					}
					md := &Metadata{ID: 1, Embed: &Metadata_Data{buf}}
					buf, err = proto.Marshal(md)
					if err != nil {
						b.Error(err)
					}
					b.StartTimer()
				}
				for i := 0; i < b.N; i++ {
					md := new(Metadata)
					err := proto.Unmarshal(buf, md)
					if err != nil {
						b.Error(err)
					}
					msg := new(Message)
					err = proto.Unmarshal(md.GetData(), msg)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
}

func BenchmarkMessageAsField(b *testing.B) {
	b.Run("Marshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				b.StopTimer()
				payload := make([]byte, bm)
				b.StartTimer()
				for i := 0; i < b.N; i++ {
					msg := &Message{Data: "Hello world", Payload: payload}

					md := &Metadata{ID: 1, Embed: &Metadata_Message{msg}}

					_, err := proto.Marshal(md)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
	b.Run("Unmarshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				var buf []byte
				{
					b.StopTimer()
					var err error
					payload := make([]byte, bm)
					msg := &Message{Data: "Hello world", Payload: payload}
					md := &Metadata{ID: 1, Embed: &Metadata_Message{msg}}
					buf, err = proto.Marshal(md)
					if err != nil {
						b.Error(err)
					}
					b.StartTimer()
				}
				for i := 0; i < b.N; i++ {
					md := new(Metadata)
					err := proto.Unmarshal(buf, md)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
}

func BenchmarkGorumsCodec(b *testing.B) {
	codec := newGorumsCodec()
	b.Run("Marshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				b.StopTimer()
				payload := make([]byte, bm)
				b.StartTimer()
				for i := 0; i < b.N; i++ {
					msg := &Message{Data: "Hello world", Payload: payload}
					md := &ordering.Metadata{MessageID: 1, MethodID: testMethodID}
					_, err := codec.gorumsMarshal(&gorumsMessage{metadata: md, message: msg})
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
	b.Run("Unmarshal", func(b *testing.B) {
		for _, bm := range benchmarks {
			b.Run(fmt.Sprintf("%d", bm), func(b *testing.B) {
				var buf []byte
				{
					b.StopTimer()
					var err error
					payload := make([]byte, bm)
					msg := &Message{Data: "Hello world", Payload: payload}
					md := &ordering.Metadata{MessageID: 1, MethodID: testMethodID}
					buf, err = codec.gorumsMarshal(&gorumsMessage{metadata: md, message: msg})
					if err != nil {
						b.Error(err)
					}
					b.StartTimer()
				}
				for i := 0; i < b.N; i++ {
					msg := newGorumsMessage(gorumsRequest)
					err := codec.gorumsUnmarshal(buf, msg)
					if err != nil {
						b.Error(err)
					}
				}
			})
		}
	})
}
