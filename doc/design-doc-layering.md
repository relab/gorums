# Design Document for Layering with gRPC and Gorums

Gorums wants to support new features that require processing of metadata
on the server side, that should not be visible to the server method implementations, and likewise for clients invoking an RPC method, should not need to concern themselves with these details.

Examples of such layers includes

* A layer to attach a configuration data structure to replies to allow a client to receive information about changes to the configuration (group membership), e.g. in a process-centric model. Similarly, the client proxy should be able to attach an epoch number that the server-side proxy will use to determine if the client has the most up-to-date configuration. These data elements should not be exposed to the client and server side code, and should seamlessly be filtered before a call is passed to the upper server-side method, and correspondingly the client-side caller.

* Another application of such layering is to pass context information about a request to other processes from a server to another server in an all-to-all communication pattern. That is, a server may implement a server-side quorum function to receive such context information, which can then be used to determine if a quorum has been received and thus decide on the next action, passing on the context information as needed by the protocol being implemented.

* The Raft implementation presented in Meland's thesis, while not using any layering, had some design challenges in deciding how to structure the Key-Value storage application vs the Raft protocol implementation. Perhaps a layering approach could alleviate this tension.

Frausing's thesis provided two implementations of such layering, one based on interceptors and the metadata support in gRPC, and one where the layer was designed as two separate gRPC services, one with a prefix `g` to separate it from the actual service that applications should use. Please see Frausing's thesis for additional details, and his code on [GitHub](https://github.com/tfrausin/reconf). There is also a question and an answer in this [gRPC issue](https://github.com/grpc/grpc-go/issues/2091).

The metadata approach is not type safe because everything must be converted to a string, and in Frausing's implementation, this requires a custom marshalling and unmarshalling implementation. Moreover, it seems that there is a larger overhead with this approach compared to the alternative with using separate gRPC interfaces.

However, it would be interesting to consider (as suggested in the gRPC issue linked above) a generic implementation that will marshal/unmarshal a protobuf structure to/from a json string that can be passed as part of the metadata feature of gRPC. What do I mean by generic here? Well, the content of the metadata to be passed in the metadata structure of an RPC request/response message should be defined as a proto message type, and the marshalling functions should be automatic. Basically, the code generator should produce marshalling functions for the metadata, and a layer-specific method that accepts the request/response object and unmarshalled metadata type as generated by the protobuf for that metadata object.

## Example using the `g` prefix approach, but with different naming scheme

Here is an example of a `Storage` implementation with a reconfiguration layer.

Assume the following protobuf message type `Config`, which is the metadata needed by the reconfiguration layer.

```protobuf
message Config {
    uint64 epoch = 1;
    repeat string addr = 2;
}
```

Note that, we don't need to maintain two separate message types for the actual configuration (list of machines) and the epoch, since if the list of machines is empty, it won't take any space in the message. Empty fields will simply be removed during marshalling.

On the server-side, our implementation of the reconfiguration layer would look something like this:

**Caveat**: The following is not quite correct because we can't have both `cfg` and `req` arguments to the `Read` call below. So necessary adjustments must be made. In fact, the client-side is more accurately specified. But I'm still not sure I like it very much.

```go
import pbm "github.com/relab/reconf/cfgproto"

func (c *pbm.Config) Read(ctx context.Context, cfg pbm.Config, req pb.ReadRequest) (pb.State, error) {
    if c.Epoch() == cfg.Epoch() {
        return c.upper.Read(ctx, req)
    } else {
        return nil, fmt.Errorf("wrong epoch")
    }
}

func (s *pb.StorageSrv) Read(ctx context.Context, req pb.ReadRequest) (pb.State, error) {
    // actual storage implementation
}
```

Here is an alternative design where we return the updated `pbm.Config`:

```go
func (c *pbm.Config) Read(ctx context.Context, cfg pbm.Config, req pb.ReadRequest) (pb.State, pbm.Config, error) {
    curEpoch, callEpoch := c.Epoch(), cfg.Epoch()
    if curEpoch == callEpoch {
        s, err := c.upper.Read(ctx, req)
        return s, nil, err
    }
    if curEpoch > callEpoch {
        return nil, curEpoch, fmt.Errorf("wrong epoch")
    } else {
        // server has outdated epoch; must reconfigure
    }
}
```

On the client side, we would still call the `Read` method as if it were a regular gRPC method:

```go
    // the mgr returns custom config objects that produce appropriate metadata for the reconfiguration layer.
    config, err := mgr.NewConfiguration(ids, qspec)
    rreply, err := config.Read(ctx, &pb.ReadRequest{})
```

The client-side reconfiguration layer (proxy), would then be implemented as follows:

```go
func (c *reconfStorageClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
    currConfig := c.GetConfig()
    inArg := &pb.ConfigReadRequest{Config: currConfig, ReadRequest: in}
    out := new(ConfigState)
    err := grpc.Invoke(ctx, "/dev.ReconfStorage/Read", inArg, out, c.cc, opts...)
    if err != nil {
        return nil, err
    }
    if out.Epoch() != currConfig.Epoch() {
        c.UpdateConfig(out.GetConfig())
    }
    realOut := out.GetState()
    return realOut, nil
}
```

Note that we need to generate a `ReconfStorage` proto to represent a combined interface:

```protobuf
service ReconfStorage {
    rpc Read(ConfigReadRequest) ConfigState;
}

message ConfigReadRequest {
    Config config = 1;
    ReadRequest req = 2;
}

message ConfigState {
    Config confg = 1;
    State state = 2;
}
```

Note that the `c.cc` connection points to the reconfiguration layer's `Read` method (in the `ReconfStorage` interface), which holds a combination of both the `ReadRequest` message and the `Config` message types.

## Open Questions

1. If our code generator produces these additional layering methods for us, do we need to register the server implementing all interfaces (both `pbm.Config` and `pb.Storage`) or can it be replaced with the top-layer only?

2. Can we support multiple layers? For example, if we want to support both reconfiguration and all-to-all communcation, and these features are best kept separate?

3. The approach above is not so flexible in that a new layer will probably want to define templates for code generation.
