# Available Options and Their Meaning

To select a call type for a Protobuf service method, specify one of the following options.
Gorums currently supports these call types (they cannot be combined):

| Call type   | Gorums option       | Description                                                       |
| ----------- | ------------------- | ----------------------------------------------------------------- |
| Ordered RPC | no option           | FIFO-ordered synchronous RPC to a single node.                    |
| Unicast     | `gorums.unicast`    | FIFO-ordered one-way asynchronous unicast.                        |
| Multicast   | `gorums.multicast`  | FIFO-ordered one-way asynchronous multicast.                      |
| Quorum Call | `gorums.quorumcall` | FIFO-ordered synchronous quorum call on a configuration of nodes. |

All call types rely on a streaming RPC call named `NodeStream` to send and receive messages to/from individual nodes.
However, the server API generated by Gorums does not expose the gRPC stream-based API.
Instead, the generated API is similar to unary gRPC, except for the handling of return values is different.

## Async and Correctable Variants

Quorum calls support asynchronous and correctable variants through *terminal methods* on the `Responses` object, not through proto options:

**Async variants** return a future (`*Async[T]`) that can be awaited later:

```go
future := ReadQC(cfgCtx, req).AsyncMajority()
// Do other work...
reply, err := future.Get()
```

**Correctable variants** provide progressive updates as more responses arrive:

```go
corr := ReadQC(cfgCtx, req).Correctable(2)  // Initial threshold
reply, level, err := corr.Get()
<-corr.Watch(3)  // Wait for higher level
reply, level, err = corr.Get()
```

See the [User Guide](user-guide.md) for details on terminal methods and response handling.

## Interceptors for Request/Response Transformation

Gorums provides interceptors to transform requests and responses on a per-node basis.
Interceptors are passed as call options and can be chained together.

### MapRequest Interceptor

Transform requests before sending to each node:

```go
cfgCtx := gorums.WithConfigContext(ctx, cfg)
resp, err := WriteQC(cfgCtx, req,
    gorums.Interceptors(
        gorums.MapRequest(func(req *WriteRequest, node *gorums.Node) *WriteRequest {
            // Customize request for each node
            return &WriteRequest{Value: fmt.Sprintf("%s-node-%d", req.Value, node.ID())}
        }),
    ),
).Majority()
```

### MapResponse Interceptor

Transform responses received from each node:

```go
resp, err := ReadQC(cfgCtx, req,
    gorums.Interceptors(
        gorums.MapResponse(func(resp *ReadResponse, node *gorums.Node) *ReadResponse {
            // Transform response, e.g., add node ID
            resp.NodeID = node.ID()
            return resp
        }),
    ),
).Majority()
```

### Map Interceptor

Apply both request and response transformations:

```go
resp, err := ReadQC(cfgCtx, req,
    gorums.Interceptors(
        gorums.Map(
            func(req *ReadRequest, node *gorums.Node) *ReadRequest {
                // Transform request
                return &ReadRequest{Key: fmt.Sprintf("%s-shard-%d", req.Key, node.ID())}
            },
            func(resp *ReadResponse, node *gorums.Node) *ReadResponse {
                // Transform response
                resp.NodeID = node.ID()
                return resp
            },
        ),
    ),
).Majority()
```

### Multicast/Unicast with MapRequest

```go
// Send different messages to each node in a multicast
WriteMulticast(ctx, cfg, msg,
    gorums.Interceptors(
        gorums.MapRequest(func(msg *WriteMessage, node *gorums.Node) *WriteMessage {
            return &WriteMessage{Shard: node.ID()}
        }),
    ),
)
```

**Note:** If `MapRequest` returns `nil` for a node, the message will not be sent to that node.

## Example Protobuf Definitions

Below is shown a list of RPC service methods, illustrating how to configure the different variants.

```proto
service Storage {
  // ReadOrdered is a FIFO-ordered RPC to a single node.
  rpc ReadOrdered(ReadRequest) returns (State) {}

  // ReadQC is a FIFO-ordered synchronous quorum call.
  // Use terminal methods (.Majority(), .First(), etc.) to retrieve results.
  // Use .AsyncMajority() for async variant, .Correctable(n) for correctable variant.
  rpc ReadQC(ReadRequest) returns (State) {
    option (gorums.quorumcall) = true;
  }

  // ReadQCStream is a FIFO-ordered synchronous quorum call with server streaming.
  // The stream keyword enables correctable calls where nodes can send multiple
  // progressive updates. Use .Correctable(n) to watch for updates as they arrive.
  rpc ReadQCStream(ReadRequest) returns (stream State) {
    option (gorums.quorumcall) = true;
  }

  // WriteMulticast is an asynchronous multicast to all nodes in a configuration.
  // No replies are collected.
  rpc WriteMulticast(State) returns (Empty) {
    option (gorums.multicast) = true;
  }

  // WriteUnicast is an asynchronous unicast to a single node.
  // No reply is collected.
  rpc WriteUnicast(State) returns (Empty) {
    option (gorums.unicast) = true;
  }

  // Write is a synchronous quorum call.
  // Per-node transformations can be applied using MapRequest/MapResponse interceptors.
  rpc Write(State) returns (WriteResponse) {
    option (gorums.quorumcall) = true;
  }
}
```

## Custom Interceptors

Beyond the built-in `MapRequest`, `MapResponse`, and `Map` interceptors, you can create custom interceptors for logging, filtering, or other cross-cutting concerns.

An interceptor has access to a `clientCtx` that provides:

- `.Request()` - the original request
- `.Config()` - the configuration being used
- `.Method()` - the RPC method name
- `.Nodes()` - all nodes in the configuration
- `.Node(id)` - get a specific node by ID
- `.responseSeq` - the response iterator (can be wrapped)

### Chaining Interceptors

Multiple interceptors can be passed to `gorums.Interceptors()` and are executed in order:

```go
cfgCtx := gorums.WithConfigContext(ctx, cfg)
resp, err := ReadQC(cfgCtx, req,
    gorums.Interceptors(
        loggingInterceptor,
        gorums.MapRequest(transformFunc),
        filterInterceptor,
    ),
).Majority()
```

### Example: Logging Interceptor

Create a logging interceptor that wraps the response iterator:

```go
func LoggingInterceptor[Req, Resp proto.Message]() gorums.QuorumInterceptor[Req, Resp] {
    return func(ctx *clientCtx[Req, Resp]) {
        startTime := time.Now()
        log.Printf("[%s] Starting quorum call with request: %v", ctx.Method(), ctx.Request())

        // Wrap the response iterator to log each response
        oldSeq := ctx.responseSeq
        ctx.responseSeq = func(yield func(gorums.NodeResponse[Resp]) bool) {
            count := 0
            for resp := range oldSeq {
                count++
                if resp.Err != nil {
                    log.Printf("[%s] Node %d error: %v", ctx.Method(), resp.NodeID, resp.Err)
                } else {
                    log.Printf("[%s] Node %d response received", ctx.Method(), resp.NodeID)
                }
                if !yield(resp) {
                    log.Printf("[%s] Iteration stopped after %d responses", ctx.Method(), count)
                    return
                }
            }
            log.Printf("[%s] Completed: %d responses in %v", ctx.Method(), count, time.Since(startTime))
        }
    }
}

// Usage
resp, err := ReadQC(cfgCtx, req,
    gorums.Interceptors(LoggingInterceptor[*ReadRequest, *ReadResponse]()),
).Majority()
```

### Example: Response Filtering Interceptor

Filter out responses that don't meet certain criteria:

```go
func FilterInterceptor[Req, Resp proto.Message](
    shouldInclude func(Resp) bool,
) gorums.QuorumInterceptor[Req, Resp] {
    return func(ctx *clientCtx[Req, Resp]) {
        oldSeq := ctx.responseSeq
        ctx.responseSeq = func(yield func(gorums.NodeResponse[Resp]) bool) {
            for resp := range oldSeq {
                // Skip responses that don't pass the filter
                if resp.Err == nil && !shouldInclude(resp.Value) {
                    continue
                }
                if !yield(resp) {
                    return
                }
            }
        }
    }
}

// Usage: only include responses with timestamp > threshold
threshold := time.Now().Add(-1 * time.Hour)
resp, err := ReadQC(cfgCtx, req,
    gorums.Interceptors(
        FilterInterceptor[*ReadRequest, *ReadResponse](func(r *ReadResponse) bool {
            return r.GetTimestamp().AsTime().After(threshold)
        }),
    ),
).Majority()
```

### Example: Retry Interceptor

Add automatic retry logic for failed nodes:

```go
func RetryInterceptor[Req, Resp proto.Message](maxRetries int) gorums.QuorumInterceptor[Req, Resp] {
    return func(ctx *clientCtx[Req, Resp]) {
        oldSeq := ctx.responseSeq
        ctx.responseSeq = func(yield func(gorums.NodeResponse[Resp]) bool) {
            retries := make(map[uint32]int)
            for resp := range oldSeq {
                if resp.Err != nil && retries[resp.NodeID] < maxRetries {
                    retries[resp.NodeID]++
                    // Retry logic would go here (requires more infrastructure)
                    log.Printf("Retrying node %d (attempt %d/%d)", resp.NodeID, retries[resp.NodeID], maxRetries)
                }
                if !yield(resp) {
                    return
                }
            }
        }
    }
}
```

**Note:** Interceptors have direct access to the `clientCtx` type from the gorums package. The exact field names and available methods can be found in `client_interceptor.go`.
