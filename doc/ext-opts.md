# Available options and their meaning

To select a call type for a protobuf service method, you must specify one or more boolean options.
Gorums currently supports the following call types:

| Call type           | Gorums option                          | gRPC needed | Streaming RPC | Description                                                        |
| ------------------- | -------------------------------------- | ----------- | ------------- | ------------------------------------------------------------------ |
| Regular RPC         | no option                              | yes         | no            | A synchronous RPC to a single node.                                |
| Ordered RPC         | `gorums.ordered`                       | no          | no            | A FIFO-ordered synchronous RPC to a single node.                   |
| Multicast           | `gorums.multicast`                     | no          | no            | A FIFO-ordered one-way asynchronous multicast.                     |
| Quorum Call         | `gorums.quorumcall`                    | yes         | no            | A synchronous quorum call on a configuration of nodes.             |
| Ordered Quorum Call | `gorums.quorumcall` + `gorums.ordered` | no          | no            | A FIFO-ordered synchronous quorum call on a configuration of nodes |
| Correctable         | `gorums.correctable`                   | yes         | optional      | A quorum call with *incremental consistency guarantees*.           |

The "gRPC needed" column shows which call types require a gRPC client and server API to be generated.
Currently, Multicast and all of the call types using `gorums.ordered` rely on an internal `NodeStream` for sending messages.
Thus, it is not necessary to generate gRPC code for services which only use these `NodeStream` based call types.
In addition, the `NodeStream` based call types use a similar but different server API generated by gorums,
whereas the other call types rely on the gRPC server API.
The `gorums.ordered` variants of other call types are intended to be come the default in the future.

Each call type may in addition specify some advanced options:

| Name               | Gorums option               | Type   | Description                                                                                    |
| ------------------ | --------------------------- | ------ | ---------------------------------------------------------------------------------------------- |
| Custom return type | `gorums.custom_return_type` | string | Makes the quorum function return a different type than the RPC response type.                  |
| Per node arguments | `gorums.per_node_arg`       | bool   | Makes it possible to send different requests objects to each node in a call.                   |
| Asynchronous       | `gorums.async`              | bool   | Makes the quorum call run asynchronously and return a "future" object to fetch the result.     |
| Concurrent         | `gorums.concurrent`         | bool   | Makes server-side RPC handlers run concurrently. FIFO ordering is lost if this option is used. |

The following matrix shows which call types support different options:

| Option             | Regular RPC | Ordered RPC | Multicast | Quorum Call | Ordered Quorum Call | Correctable |
| ------------------ | ----------- | ----------- | --------- | ----------- | ------------------- | ----------- |
| Custom return type | N/A         | N/A         | N/A       | Yes         | Yes                 | Yes         |
| Per node arguments | N/A         | N/A         | Yes       | Yes         | Yes                 | Yes         |
| Asynchronous       | No          | No          | N/A       | Yes         | Yes                 | No          |
| Concurrent         | N/A         | Yes         | Yes       | N/A         | Yes                 | N/A         |

```proto
service Storage {
  // ReadNoQC is a plain gRPC call.
  rpc ReadNoQC(ReadRequest) returns (State) {}

  // Read is a synchronous quorum call.
  rpc Read(ReadRequest) returns (State) {
    option (gorums.quorumcall) = true;
  }

  // ReadFuture is an asynchronous quorum call that
  // returns a future object for retrieving results.
  rpc ReadFuture(ReadRequest) returns (State) {
    option (gorums.qc_future) = true;
  }

  // ReadCustomReturn is a synchronous quorum call with a custom return type
  rpc ReadCustomReturn(ReadRequest) returns (State) {
    option (gorums.quorumcall)    = true;
    option (gorums.custom_return_type)  = "MyState";
  }

  // ReadCorrectable is an asynchronous correctable quorum call that
  // returns a correctable object for retrieving results.
  rpc ReadCorrectable(ReadRequest) returns (State) {
    option (gorums.correctable) = true;
  }

  // ReadPrelim is an asynchronous correctable quorum call that
  // returns a correctable object for retrieving results.
  rpc ReadPrelim(ReadRequest) returns (stream State) {
    option (gorums.correctable_pr) = true;
  }

  // Write is a synchronous quorum call.
  // The request argument (State) is passed to the associated
  // quorum function, WriteQF, for this method.
  rpc Write(State) returns (WriteResponse) {
    option (gorums.quorumcall)  = true;
    option (gorums.qf_with_req) = true;
  }

  // WriteFuture is an asynchronous quorum call that
  // returns a future object for retrieving results.
  // The request argument (State) is passed to the associated
  // quorum function, WriteFutureQF, for this method.
  rpc WriteFuture(State) returns (WriteResponse) {
    option (gorums.qc_future) = true;
    option (gorums.qf_with_req) = true;
  }

  // WriteAsync is an asynchronous multicast to all nodes in a configuration.
  // No replies are collected.
  rpc WriteAsync(stream State) returns (Empty) {
    option (gorums.multicast) = true;
  }

  // WritePerNode is a synchronous quorum call, where,
  // for each node, a provided function is called to determine
  // the argument to be sent to that node.
  rpc WritePerNode(State) returns (WriteResponse) {
    option (gorums.quorumcall)  = true;
    option (gorums.per_node_arg)  = true;
  }
}
```

## Adding a new extension option

TODO(meling) these instructions are outdated

1. Add your extension option to `gorums.proto`. We currently only have method options.
2. Run `make gorumsprotoopts` to regenerate the `gorums.pb.go` file. (TODO we could probably avoid using a make file for this and instead do `go generate`)
3. Add a check function, such as `hasPerNodeArgExtension()`, for your option in `plugins/gorums/ext.go`.
4. Update the `plugins/gorums/gorums.go` as follows
   a. add the option `PerNodeArg` bool to the `serviceMethod` struct.
   b. add the option to initialize of the `serviceMethod` struct in the `verifyExtensionsAndCreate` function, like this: `PerNodeArg:        hasPerNodeArgExtension(method),`
   c. update the logic in the `isQuorumCallVariant` function if necessary.
   d. update the error handling logic in `verifyExtensionsAndCreate`.
5. Update the template files (`.tmpl` in `dev` folder) related to your option. This is were your on your own.
6. To regenerate the gorums plugin, you need to run `make dev` so that new proto files will understand your option.
7. Update the `dev/storage.proto` file with your new option (probably on a new method).
8. To use the new option in the `dev/storage.proto` file, you need to run `make devproto`.
