// Code generated by protoc-gen-gorums. DO NOT EDIT.

package zorums

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	fmt "fmt"
	empty "github.com/golang/protobuf/ptypes/empty"
	ordering "github.com/relab/gorums/ordering"
	trace "golang.org/x/net/trace"
	grpc "google.golang.org/grpc"
	backoff "google.golang.org/grpc/backoff"
	codes "google.golang.org/grpc/codes"
	encoding "google.golang.org/grpc/encoding"
	status "google.golang.org/grpc/status"
	protowire "google.golang.org/protobuf/encoding/protowire"
	proto "google.golang.org/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	fnv "hash/fnv"
	io "io"
	log "log"
	math "math"
	rand "math/rand"
	net "net"
	sort "sort"
	strconv "strconv"
	strings "strings"
	sync "sync"
	atomic "sync/atomic"
	time "time"
)

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id    uint32
	nodes []*Node
	n     int
	mgr   *Manager
	qspec QuorumSpec
	errs  chan GRPCError
}

// NewConfig returns a configuration for the given node addresses and quorum spec.
// The returned func() must be called to close the underlying connections.
// This is an experimental API.
func NewConfig(qspec QuorumSpec, opts ...ManagerOption) (*Configuration, func(), error) {
	man, err := NewManager(opts...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create manager: %v", err)
	}
	c, err := man.NewConfiguration(man.NodeIDs(), qspec)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create configuration: %v", err)
	}
	return c, func() { man.Close() }, nil
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration. IDs are returned in the same order as they were provided in
// the creation of the Configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Configuration.
func (c *Configuration) Nodes() []*Node {
	return c.nodes
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("config-%d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// SubError returns a channel for listening to individual node errors. Currently
// only a single listener is supported.
func (c *Configuration) SubError() <-chan GRPCError {
	return c.errs
}

const gorumsContentType = "gorums"

func init() {
	encoding.RegisterCodec(newGorumsCodec())
}

type gorumsMsgType uint8

const (
	gorumsRequest gorumsMsgType = iota + 1
	gorumsResponse
)

type gorumsMessage struct {
	metadata *ordering.Metadata
	message  protoreflect.ProtoMessage
	msgType  gorumsMsgType
}

// newGorumsMessage creates a new gorumsMessage struct for unmarshaling.
// msgType specifies the type of message that should be unmarshaled.
func newGorumsMessage(msgType gorumsMsgType) *gorumsMessage {
	return &gorumsMessage{metadata: &ordering.Metadata{}, msgType: msgType}
}

type gorumsCodec struct {
	marshaler   proto.MarshalOptions
	unmarshaler proto.UnmarshalOptions
}

func newGorumsCodec() *gorumsCodec {
	return &gorumsCodec{
		marshaler:   proto.MarshalOptions{AllowPartial: true},
		unmarshaler: proto.UnmarshalOptions{AllowPartial: true},
	}
}

func (c gorumsCodec) Name() string {
	return gorumsContentType
}

func (c gorumsCodec) String() string {
	return gorumsContentType
}

func (c gorumsCodec) Marshal(m interface{}) (b []byte, err error) {
	switch msg := m.(type) {
	case *gorumsMessage:
		return c.gorumsMarshal(msg)
	case protoreflect.ProtoMessage:
		return c.marshaler.Marshal(msg)
	default:
		return nil, fmt.Errorf("gorumsCodec: don't know how to marshal message of type '%T'", m)
	}
}

// gorumsMarshal marshals a metadata and a data message into a single byte slice.
func (c gorumsCodec) gorumsMarshal(msg *gorumsMessage) (b []byte, err error) {
	mdSize := c.marshaler.Size(msg.metadata)
	b = protowire.AppendVarint(b, uint64(mdSize))
	b, err = c.marshaler.MarshalAppend(b, msg.metadata)
	if err != nil {
		return nil, err
	}

	msgSize := c.marshaler.Size(msg.message)
	b = protowire.AppendVarint(b, uint64(msgSize))
	b, err = c.marshaler.MarshalAppend(b, msg.message)
	if err != nil {
		return nil, err
	}
	return b, nil
}

func (c gorumsCodec) Unmarshal(b []byte, m interface{}) (err error) {
	switch msg := m.(type) {
	case *gorumsMessage:
		return c.gorumsUnmarshal(b, msg)
	case protoreflect.ProtoMessage:
		return c.unmarshaler.Unmarshal(b, msg)
	default:
		return fmt.Errorf("gorumsCodec: don't know how to unmarshal message of type '%T'", m)
	}
}

// gorumsUnmarshal unmarshals a metadata and a data message from a byte slice.
func (c gorumsCodec) gorumsUnmarshal(b []byte, msg *gorumsMessage) (err error) {
	mdBuf, mdLen := protowire.ConsumeBytes(b)
	err = c.unmarshaler.Unmarshal(mdBuf, msg.metadata)
	if err != nil {
		return err
	}
	info, ok := orderingMethods[msg.metadata.MethodID]
	if !ok {
		return fmt.Errorf("gorumsCodec: Unknown MethodID")
	}
	switch msg.msgType {
	case gorumsRequest:
		msg.message = info.requestType.New().Interface()
	case gorumsResponse:
		msg.message = info.responseType.New().Interface()
	default:
		return fmt.Errorf("gorumsCodec: Unknown message type")
	}
	msgBuf, _ := protowire.ConsumeBytes(b[mdLen:])
	err = c.unmarshaler.Unmarshal(msgBuf, msg.message)
	if err != nil {
		return err
	}
	return nil
}

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

// A QuorumCallError is used to report that a quorum call failed.
type QuorumCallError struct {
	Reason     string
	ReplyCount int
	Errors     []GRPCError
}

func (e QuorumCallError) Error() string {
	var b bytes.Buffer
	b.WriteString("quorum call error: ")
	b.WriteString(e.Reason)
	b.WriteString(fmt.Sprintf(" (errors: %d, replies: %d)", len(e.Errors), e.ReplyCount))
	if len(e.Errors) == 0 {
		return b.String()
	}
	b.WriteString("\ngrpc errors:\n")
	for _, err := range e.Errors {
		b.WriteByte('\t')
		b.WriteString(fmt.Sprintf("node %d: %v", err.NodeID, err.Cause))
		b.WriteByte('\n')
	}
	return b.String()
}

// GRPCError is used to report that a single gRPC call failed.
type GRPCError struct {
	NodeID uint32
	Cause  error
}

func (e GRPCError) Error() string {
	return fmt.Sprintf("node %d: %v", e.NodeID, e.Cause.Error())
}

// LevelNotSet is the zero value level used to indicate that no level (and
// thereby no reply) has been set for a correctable quorum call.
const LevelNotSet = -1

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	mu       sync.Mutex
	nodes    []*Node
	lookup   map[uint32]*Node
	configs  map[uint32]*Configuration
	eventLog trace.EventLog

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions

	*receiveQueue
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(opts ...ManagerOption) (*Manager, error) {

	m := &Manager{
		lookup:       make(map[uint32]*Node),
		configs:      make(map[uint32]*Configuration),
		receiveQueue: newReceiveQueue(),
		opts:         newManagerOptions(),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	m.opts.grpcDialOpts = append(m.opts.grpcDialOpts, grpc.WithDefaultCallOptions(
		grpc.CallContentSubtype(gorumsContentType),
		grpc.ForceCodec(newGorumsCodec()),
	))

	if len(m.opts.addrsList) == 0 && len(m.opts.idMapping) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	if m.opts.backoff != backoff.DefaultConfig {
		m.opts.grpcDialOpts = append(m.opts.grpcDialOpts, grpc.WithConnectParams(
			grpc.ConnectParams{Backoff: m.opts.backoff},
		))
	}

	var nodeAddrs []string
	if m.opts.idMapping != nil {
		for naddr, id := range m.opts.idMapping {
			if m.lookup[id] != nil {
				err := fmt.Errorf("two node ids are identical(id %d). Node ids has to be unique!", id)
				return nil, ManagerCreationError(err)
			}
			nodeAddrs = append(nodeAddrs, naddr)
			node, err := m.createNode(naddr, id)
			if err != nil {
				return nil, ManagerCreationError(err)
			}
			m.lookup[node.id] = node
			m.nodes = append(m.nodes, node)
		}

		// Sort nodes since map iteration is non-deterministic.
		OrderedBy(ID).Sort(m.nodes)

	} else if m.opts.addrsList != nil {
		nodeAddrs = m.opts.addrsList
		for _, naddr := range m.opts.addrsList {
			node, err := m.createNode(naddr, 0)
			if err != nil {
				return nil, ManagerCreationError(err)
			}
			m.lookup[node.id] = node
			m.nodes = append(m.nodes, node)
		}
	}

	if m.opts.trace {
		title := strings.Join(nodeAddrs, ",")
		m.eventLog = trace.NewEventLog("gorums.Manager", title)
	}

	if err := m.connectAll(); err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	if m.eventLog != nil {
		m.eventLog.Printf("ready")
	}

	return m, nil
}

func (m *Manager) createNode(addr string, id uint32) (*Node, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	if id == 0 {
		h := fnv.New32a()
		_, _ = h.Write([]byte(tcpAddr.String()))
		id = h.Sum32()
	}

	if _, found := m.lookup[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}
	node.createOrderedStream(m.receiveQueue, m.opts)

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}

	if m.eventLog != nil {
		m.eventLog.Printf("connecting")
	}

	for _, node := range m.nodes {
		err := node.connect(m.opts)
		if err != nil {
			if m.eventLog != nil {
				m.eventLog.Errorf("connect failed, error connecting to node %s, error: %v", node.addr, err)
			}
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		if m.eventLog != nil {
			m.eventLog.Printf("closing")
		}
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node. IDs are returned in
// the same order as they were provided in the creation of the Manager.
func (m *Manager) NodeIDs() []uint32 {
	m.mu.Lock()
	defer m.mu.Unlock()
	ids := make([]uint32, 0, len(m.nodes))
	for _, node := range m.nodes {
		ids = append(ids, node.ID())
	}
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	node, found = m.lookup[id]
	return node, found
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Manager.
func (m *Manager) Nodes() []*Node {
	m.mu.Lock()
	defer m.mu.Unlock()
	return m.nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.mu.Lock()
	defer m.mu.Unlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.mu.Lock()
	defer m.mu.Unlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec) (*Configuration, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}

	var nodes []*Node
	unique := make(map[uint32]struct{})
	var uniqueIDs []uint32
	for _, nid := range ids {
		// ensure that identical IDs are only counted once
		if _, duplicate := unique[nid]; duplicate {
			continue
		}
		unique[nid] = struct{}{}
		uniqueIDs = append(uniqueIDs, nid)

		node, found := m.lookup[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		nodes = append(nodes, node)
	}

	// node IDs are sorted to ensure a globally consistent configuration ID
	sort.Sort(idSlice(uniqueIDs))

	h := fnv.New32a()
	for _, id := range uniqueIDs {
		_ = binary.Write(h, binary.LittleEndian, id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:    cid,
		nodes: nodes,
		n:     len(nodes),
		mgr:   m,
		qspec: qspec,
	}
	m.configs[cid] = c

	return c, nil
}

type idSlice []uint32

func (p idSlice) Len() int { return len(p) }

func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }

func (p idSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }

const nilAngleString = "<nil>"

// Node encapsulates the state of a node on which a remote procedure call
// can be performed.
type Node struct {
	// Only assigned at creation.
	id      uint32
	addr    string
	conn    *grpc.ClientConn
	cancel  func()
	mu      sync.Mutex
	lastErr error
	latency time.Duration

	*orderedNodeStream

	// embed generated nodeServices
	nodeServices
}

func (n *Node) createOrderedStream(rq *receiveQueue, opts managerOptions) {
	n.orderedNodeStream = &orderedNodeStream{
		receiveQueue: rq,
		sendQ:        make(chan *gorumsMessage, opts.sendBuffer),
		node:         n,
		backoff:      opts.backoff,
		rand:         rand.New(rand.NewSource(time.Now().UnixNano())),
	}
}

// connect to this node to facilitate gRPC calls and optionally client streams.
func (n *Node) connect(opts managerOptions) error {
	var err error
	ctx, cancel := context.WithTimeout(context.Background(), opts.nodeDialTimeout)
	defer cancel()
	n.conn, err = grpc.DialContext(ctx, n.addr, opts.grpcDialOpts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %w", err)
	}
	// a context for all of the streams
	ctx, n.cancel = context.WithCancel(context.Background())
	// only start ordering RPCs when needed
	if hasOrderingMethods {
		err = n.connectOrderedStream(ctx, n.conn)
		if err != nil {
			return fmt.Errorf("starting stream failed: %w", err)
		}
	}
	return n.connectStream(ctx) // call generated method
}

// close this node for further calls and optionally stream.
func (n *Node) close() error {
	if err := n.conn.Close(); err != nil {
		return fmt.Errorf("%d: conn close error: %w", n.id, err)
	}
	err := n.closeStream() // call generated method
	n.cancel()
	return err
}

// ID returns the ID of n.
func (n *Node) ID() uint32 {
	if n != nil {
		return n.id
	}
	return 0
}

// Address returns network address of n.
func (n *Node) Address() string {
	if n != nil {
		return n.addr
	}
	return nilAngleString
}

// Port returns network port of n.
func (n *Node) Port() string {
	if n != nil {
		_, port, _ := net.SplitHostPort(n.addr)
		return port
	}
	return nilAngleString
}

func (n *Node) String() string {
	if n != nil {
		return fmt.Sprintf("addr: %s", n.addr)
	}
	return nilAngleString
}

// FullString returns a more descriptive string representation of n that
// includes id, network address and latency information.
func (n *Node) FullString() string {
	if n != nil {
		n.mu.Lock()
		defer n.mu.Unlock()
		return fmt.Sprintf(
			"node %d | addr: %s | latency: %v",
			n.id, n.addr, n.latency,
		)
	}
	return nilAngleString
}

func (n *Node) setLastErr(err error) {
	n.mu.Lock()
	defer n.mu.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.mu.Lock()
	defer n.mu.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.mu.Lock()
	defer n.mu.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.mu.Lock()
	defer n.mu.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// Port sorts nodes by their port number in increasing order.
// Warning: This function may be removed in the future.
var Port = func(n1, n2 *Node) bool {
	p1, _ := strconv.Atoi(n1.Port())
	p2, _ := strconv.Atoi(n2.Port())
	return p1 < p2
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency
}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

type managerOptions struct {
	grpcDialOpts    []grpc.DialOption
	nodeDialTimeout time.Duration
	logger          *log.Logger
	noConnect       bool
	trace           bool
	backoff         backoff.Config
	sendBuffer      uint
	idMapping       map[string]uint32
	addrsList       []string
}

func newManagerOptions() managerOptions {
	return managerOptions{
		backoff:    backoff.DefaultConfig,
		sendBuffer: 0,
	}
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithDialTimeout returns a ManagerOption which is used to set the dial
// context timeout to be used when initially connecting to each node in its pool.
func WithDialTimeout(timeout time.Duration) ManagerOption {
	return func(o *managerOptions) {
		o.nodeDialTimeout = timeout
	}
}

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = append(o.grpcDialOpts, opts...)
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithTracing controls whether to trace quorum calls for this Manager instance
// using the golang.org/x/net/trace package. Tracing is currently only supported
// for regular quorum calls.
func WithTracing() ManagerOption {
	return func(o *managerOptions) {
		o.trace = true
	}
}

// WithBackoff allows for changing the backoff delays used by Gorums.
func WithBackoff(backoff backoff.Config) ManagerOption {
	return func(o *managerOptions) {
		o.backoff = backoff
	}
}

// WithSendBufferSize allows for changing the size of the send buffer used by Gorums.
// A larger buffer might achieve higher throughput for asynchronous calltypes, but at
// the cost of latency.
func WithSendBufferSize(size uint) ManagerOption {
	return func(o *managerOptions) {
		o.sendBuffer = size
	}
}

// WithNodeMap returns a ManagerOption containing the provided mapping from node addresses to application-specific IDs.
func WithNodeMap(idMap map[string]uint32) ManagerOption {
	return func(o *managerOptions) {
		o.idMapping = idMap
	}
}

// WithNodeList returns a ManagerOption containing the provided list of node addresses.
// With this option, NodeIDs are generated by the Manager.
func WithNodeList(addrsList []string) ManagerOption {
	return func(o *managerOptions) {
		o.addrsList = addrsList
	}
}

type methodInfo struct {
	requestType  protoreflect.Message
	responseType protoreflect.Message
}

type orderingResult struct {
	nid   uint32
	reply protoreflect.ProtoMessage
	err   error
}

type receiveQueue struct {
	msgID    uint64
	recvQ    map[uint64]chan *orderingResult
	recvQMut sync.RWMutex
}

func newReceiveQueue() *receiveQueue {
	return &receiveQueue{
		recvQ: make(map[uint64]chan *orderingResult),
	}
}

func (m *receiveQueue) nextMsgID() uint64 {
	return atomic.AddUint64(&m.msgID, 1)
}

func (m *receiveQueue) putChan(id uint64, c chan *orderingResult) {
	m.recvQMut.Lock()
	m.recvQ[id] = c
	m.recvQMut.Unlock()
}

func (m *receiveQueue) deleteChan(id uint64) {
	m.recvQMut.Lock()
	delete(m.recvQ, id)
	m.recvQMut.Unlock()
}

func (m *receiveQueue) putResult(id uint64, result *orderingResult) {
	m.recvQMut.RLock()
	c, ok := m.recvQ[id]
	m.recvQMut.RUnlock()
	if ok {
		c <- result
	}
}

type orderedNodeStream struct {
	*receiveQueue
	sendQ        chan *gorumsMessage
	node         *Node // needed for ID and setLastError
	backoff      backoff.Config
	rand         *rand.Rand
	gorumsClient ordering.GorumsClient
	gorumsStream ordering.Gorums_NodeStreamClient
	streamMut    sync.RWMutex
	streamBroken bool
}

func (s *orderedNodeStream) connectOrderedStream(ctx context.Context, conn *grpc.ClientConn) error {
	var err error
	s.gorumsClient = ordering.NewGorumsClient(conn)
	s.gorumsStream, err = s.gorumsClient.NodeStream(ctx)
	if err != nil {
		return err
	}
	go s.sendMsgs(ctx)
	go s.recvMsgs(ctx)
	return nil
}

func (s *orderedNodeStream) sendMsgs(ctx context.Context) {
	var req *gorumsMessage
	for {
		select {
		case <-ctx.Done():
			return
		case req = <-s.sendQ:
		}
		// return error if stream is broken
		if s.streamBroken {
			err := status.Errorf(codes.Unavailable, "stream is down")
			s.putResult(req.metadata.MessageID, &orderingResult{nid: s.node.ID(), reply: nil, err: err})
			continue
		}
		// else try to send message
		s.streamMut.RLock()
		err := s.gorumsStream.SendMsg(req)
		if err == nil {
			s.streamMut.RUnlock()
			continue
		}
		s.streamBroken = true
		s.streamMut.RUnlock()
		s.node.setLastErr(err)
		// return the error
		s.putResult(req.metadata.MessageID, &orderingResult{nid: s.node.ID(), reply: nil, err: err})
	}
}

func (s *orderedNodeStream) recvMsgs(ctx context.Context) {
	for {
		resp := newGorumsMessage(gorumsResponse)
		s.streamMut.RLock()
		err := s.gorumsStream.RecvMsg(resp)
		if err != nil {
			s.streamBroken = true
			s.streamMut.RUnlock()
			s.node.setLastErr(err)
			// attempt to reconnect
			s.reconnectStream(ctx)
		} else {
			s.streamMut.RUnlock()
			s.putResult(resp.metadata.MessageID, &orderingResult{nid: s.node.ID(), reply: resp.message, err: nil})
		}

		select {
		case <-ctx.Done():
			return
		default:
		}
	}
}

func (s *orderedNodeStream) reconnectStream(ctx context.Context) {
	s.streamMut.Lock()
	defer s.streamMut.Unlock()

	var retries float64
	for {
		var err error
		s.gorumsStream, err = s.gorumsClient.NodeStream(ctx)
		if err == nil {
			s.streamBroken = false
			return
		}
		s.node.setLastErr(err)
		delay := float64(s.backoff.BaseDelay)
		max := float64(s.backoff.MaxDelay)
		for r := retries; delay < max && r > 0; r-- {
			delay *= s.backoff.Multiplier
		}
		delay = math.Min(delay, max)
		delay *= 1 + s.backoff.Jitter*(rand.Float64()*2-1)
		select {
		case <-time.After(time.Duration(delay)):
			retries++
		case <-ctx.Done():
			return
		}
	}
}

// requestHandler is used to fetch a response message based on the request.
// A requestHandler should receive a message from the server, unmarshal it into
// the proper type for that Method's request type, call a user provided Handler,
// and return a marshaled result to the server.
type requestHandler func(*gorumsMessage, chan<- *gorumsMessage)

type orderingServer struct {
	handlers map[int32]requestHandler
	opts     *serverOptions
	ordering.UnimplementedGorumsServer
}

func newOrderingServer(opts *serverOptions) *orderingServer {
	s := &orderingServer{
		handlers: make(map[int32]requestHandler),
		opts:     opts,
	}
	return s
}

// NodeStream handles a connection to a single client. The stream is aborted if there
// is any error with sending or receiving.
func (s *orderingServer) NodeStream(srv ordering.Gorums_NodeStreamServer) error {
	finished := make(chan *gorumsMessage, s.opts.buffer)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case msg := <-finished:
				err := srv.SendMsg(msg)
				if err != nil {
					return
				}
			}
		}
	}()

	for {
		req := newGorumsMessage(gorumsRequest)
		err := srv.RecvMsg(req)
		if err != nil {
			return err
		}
		if handler, ok := s.handlers[req.metadata.MethodID]; ok {
			handler(req, finished)
		}
	}
}

type serverOptions struct {
	buffer   uint
	grpcOpts []grpc.ServerOption
}

// ServerOption is used to change settings for the GorumsServer
type ServerOption func(*serverOptions)

// WithServerBufferSize sets the buffer size for the server.
// A larger buffer may result in higher throughput at the cost of higher latency.
func WithServerBufferSize(size uint) ServerOption {
	return func(o *serverOptions) {
		o.buffer = size
	}
}

func WithGRPCServerOptions(opts ...grpc.ServerOption) ServerOption {
	return func(o *serverOptions) {
		o.grpcOpts = append(o.grpcOpts, opts...)
	}
}

// GorumsServer serves all ordering based RPCs using registered handlers.
type GorumsServer struct {
	srv        *orderingServer
	grpcServer *grpc.Server
}

// NewGorumsServer returns a new instance of GorumsServer.
func NewGorumsServer(opts ...ServerOption) *GorumsServer {
	var serverOpts serverOptions
	for _, opt := range opts {
		opt(&serverOpts)
	}
	serverOpts.grpcOpts = append(serverOpts.grpcOpts, grpc.CustomCodec(newGorumsCodec()))
	s := &GorumsServer{
		srv:        newOrderingServer(&serverOpts),
		grpcServer: grpc.NewServer(serverOpts.grpcOpts...),
	}
	ordering.RegisterGorumsServer(s.grpcServer, s.srv)
	return s
}

// Serve starts serving on the listener.
func (s *GorumsServer) Serve(listener net.Listener) error {
	return s.grpcServer.Serve(listener)
}

// GracefulStop waits for all RPCs to finish before stopping.
func (s *GorumsServer) GracefulStop() {
	s.grpcServer.GracefulStop()
}

// Stop stops the server immediately.
func (s *GorumsServer) Stop() {
	s.grpcServer.Stop()
}

type traceInfo struct {
	trace.Trace
	firstLine firstLine
}

type firstLine struct {
	deadline time.Duration
	cid      uint32
}

func (f firstLine) String() string {
	if f.deadline != 0 {
		return fmt.Sprintf("QC: to config%d deadline: %d", f.cid, f.deadline)
	}
	return fmt.Sprintf("QC: to config%d deadline: none", f.cid)
}

type payload struct {
	sent bool
	id   uint32
	msg  interface{}
}

func (p payload) String() string {
	if p.sent {
		return fmt.Sprintf("sent: %v", p.msg)
	}
	return fmt.Sprintf("recv from %d: %v", p.id, p.msg)
}

type qcresult struct {
	ids   []uint32
	reply interface{}
	err   error
}

func (q qcresult) String() string {
	if q.err == nil {
		return fmt.Sprintf("recv QC reply: ids: %v, reply: %v", q.ids, q.reply)
	}
	return fmt.Sprintf("recv QC reply: ids: %v, reply: %v, error: %v", q.ids, q.reply, q.err)
}

func appendIfNotPresent(set []uint32, x uint32) []uint32 {
	for _, y := range set {
		if y == x {
			return set
		}
	}
	return append(set, x)
}

// QuorumCallFuture plain.
func (c *Configuration) QuorumCallFuture(ctx context.Context, in *Request, opts ...grpc.CallOption) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFuture(ctx, in, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFuture(ctx context.Context, in *Request, resp *FutureResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFuture")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallFuture(ctx, in, replyChan)
	}

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFutureQF(in, replies); quorum {
				resp.Response, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.Response, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.Response, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFuture(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFuture", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallFuturePerNodeArg with per_node_arg option.
func (c *Configuration) QuorumCallFuturePerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFuturePerNodeArg(ctx, in, f, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFuturePerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *FutureResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFuturePerNodeArg")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.QuorumCallFuturePerNodeArg(ctx, nodeArg, replyChan)
	}

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFuturePerNodeArgQF(in, replies); quorum {
				resp.Response, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.Response, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.Response, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFuturePerNodeArg(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFuturePerNodeArg", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallFutureCustomReturnType with custom_return_type option.
func (c *Configuration) QuorumCallFutureCustomReturnType(ctx context.Context, in *Request, opts ...grpc.CallOption) *FutureMyResponse {
	fut := &FutureMyResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFutureCustomReturnType(ctx, in, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFutureCustomReturnType(ctx context.Context, in *Request, resp *FutureMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFutureCustomReturnType")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallFutureCustomReturnType(ctx, in, replyChan)
	}

	var (
		reply   *MyResponse
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFutureCustomReturnTypeQF(in, replies); quorum {
				resp.MyResponse, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.MyResponse, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.MyResponse, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFutureCustomReturnType(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFutureCustomReturnType", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallFutureCombo with all supported options.
func (c *Configuration) QuorumCallFutureCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *FutureMyResponse {
	fut := &FutureMyResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFutureCombo(ctx, in, f, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFutureCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *FutureMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFutureCombo")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.QuorumCallFutureCombo(ctx, nodeArg, replyChan)
	}

	var (
		reply   *MyResponse
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFutureComboQF(in, replies); quorum {
				resp.MyResponse, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.MyResponse, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.MyResponse, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFutureCombo(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFutureCombo", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallFuture2 plain; with same return type: Response.
func (c *Configuration) QuorumCallFuture2(ctx context.Context, in *Request, opts ...grpc.CallOption) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFuture2(ctx, in, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFuture2(ctx context.Context, in *Request, resp *FutureResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFuture2")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallFuture2(ctx, in, replyChan)
	}

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFuture2QF(in, replies); quorum {
				resp.Response, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.Response, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.Response, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFuture2(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFuture2", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallFutureEmpty for testing imported message type.
func (c *Configuration) QuorumCallFutureEmpty(ctx context.Context, in *Request, opts ...grpc.CallOption) *FutureEmpty {
	fut := &FutureEmpty{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFutureEmpty(ctx, in, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFutureEmpty(ctx context.Context, in *Request, resp *FutureEmpty, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFutureEmpty")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Empty, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalEmpty, expected)
	for _, n := range c.nodes {
		go n.QuorumCallFutureEmpty(ctx, in, replyChan)
	}

	var (
		reply   *empty.Empty
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*empty.Empty, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFutureEmptyQF(in, replies); quorum {
				resp.Empty, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.Empty, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.Empty, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFutureEmpty(ctx context.Context, in *Request, replyChan chan<- internalEmpty) {
	reply := new(empty.Empty)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFutureEmpty", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalEmpty{n.id, reply, err}
}

// QuorumCallFutureEmpty2 for testing imported message type; with same return
// type as QuorumCallFuture: Response.
func (c *Configuration) QuorumCallFutureEmpty2(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(fut.c)
		c.quorumCallFutureEmpty2(ctx, in, fut, opts...)
	}()
	return fut
}

func (c *Configuration) quorumCallFutureEmpty2(ctx context.Context, in *empty.Empty, resp *FutureResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallFutureEmpty2")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallFutureEmpty2(ctx, in, replyChan)
	}

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if reply, quorum = c.qspec.QuorumCallFutureEmpty2QF(in, replies); quorum {
				resp.Response, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.Response, resp.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			resp.Response, resp.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

func (n *Node) QuorumCallFutureEmpty2(ctx context.Context, in *empty.Empty, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallFutureEmpty2", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// Correctable plain.
func (c *Configuration) Correctable(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableResponse {
	corr := &CorrectableResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctable(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctable(ctx context.Context, in *Request, resp *CorrectableResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "Correctable")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.Correctable(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) Correctable(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/Correctable", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// CorrectablePerNodeArg with per_node_arg option.
func (c *Configuration) CorrectablePerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *CorrectableResponse {
	corr := &CorrectableResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctablePerNodeArg(ctx, in, f, corr, opts...)
	return corr
}

func (c *Configuration) correctablePerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *CorrectableResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectablePerNodeArg")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.CorrectablePerNodeArg(ctx, nodeArg, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectablePerNodeArgQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectablePerNodeArg(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/CorrectablePerNodeArg", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// CorrectableCustomReturnType with custom_return_type option.
func (c *Configuration) CorrectableCustomReturnType(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableMyResponse {
	corr := &CorrectableMyResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableCustomReturnType(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableCustomReturnType(ctx context.Context, in *Request, resp *CorrectableMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableCustomReturnType")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.CorrectableCustomReturnType(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *MyResponse
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableCustomReturnTypeQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableCustomReturnType(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/CorrectableCustomReturnType", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// CorrectableCombo with all supported options.
func (c *Configuration) CorrectableCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *CorrectableMyResponse {
	corr := &CorrectableMyResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableCombo(ctx, in, f, corr, opts...)
	return corr
}

func (c *Configuration) correctableCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *CorrectableMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableCombo")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.CorrectableCombo(ctx, nodeArg, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *MyResponse
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableComboQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableCombo(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/CorrectableCombo", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// CorrectableEmpty for testing imported message type.
func (c *Configuration) CorrectableEmpty(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableEmpty {
	corr := &CorrectableEmpty{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableEmpty(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableEmpty(ctx context.Context, in *Request, resp *CorrectableEmpty, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableEmpty")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Empty, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalEmpty, expected)
	for _, n := range c.nodes {
		go n.CorrectableEmpty(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*empty.Empty, c.n*2)
		clevel  = LevelNotSet
		reply   *empty.Empty
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableEmptyQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableEmpty(ctx context.Context, in *Request, replyChan chan<- internalEmpty) {
	reply := new(empty.Empty)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/CorrectableEmpty", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalEmpty{n.id, reply, err}
}

// CorrectableEmpty2 for testing imported message type; with same return
// type as Correctable: Response.
func (c *Configuration) CorrectableEmpty2(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) *CorrectableResponse {
	corr := &CorrectableResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableEmpty2(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableEmpty2(ctx context.Context, in *empty.Empty, resp *CorrectableResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableEmpty2")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.CorrectableEmpty2(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableEmpty2QF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs)+len(replies) == expected {
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableEmpty2(ctx context.Context, in *empty.Empty, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/CorrectableEmpty2", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// CorrectableStream plain.
func (c *Configuration) CorrectableStream(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableStreamResponse {
	corr := &CorrectableStreamResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStream(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableStream(ctx context.Context, in *Request, resp *CorrectableStreamResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStream")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.CorrectableStream(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStream(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStream(ctx, in)
	if err != nil {
		replyChan <- internalResponse{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalResponse{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// CorrectablePerNodeArg with per_node_arg option.
func (c *Configuration) CorrectableStreamPerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *CorrectableStreamResponse {
	corr := &CorrectableStreamResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStreamPerNodeArg(ctx, in, f, corr, opts...)
	return corr
}

func (c *Configuration) correctableStreamPerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *CorrectableStreamResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStreamPerNodeArg")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.CorrectableStreamPerNodeArg(ctx, nodeArg, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamPerNodeArgQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStreamPerNodeArg(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStreamPerNodeArg(ctx, in)
	if err != nil {
		replyChan <- internalResponse{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalResponse{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// CorrectableCustomReturnType with custom_return_type option.
func (c *Configuration) CorrectableStreamCustomReturnType(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableStreamMyResponse {
	corr := &CorrectableStreamMyResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStreamCustomReturnType(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableStreamCustomReturnType(ctx context.Context, in *Request, resp *CorrectableStreamMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStreamCustomReturnType")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.CorrectableStreamCustomReturnType(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *MyResponse
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamCustomReturnTypeQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStreamCustomReturnType(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStreamCustomReturnType(ctx, in)
	if err != nil {
		replyChan <- internalResponse{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalResponse{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// CorrectableCombo with all supported options.
func (c *Configuration) CorrectableStreamCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) *CorrectableStreamMyResponse {
	corr := &CorrectableStreamMyResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStreamCombo(ctx, in, f, corr, opts...)
	return corr
}

func (c *Configuration) correctableStreamCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, resp *CorrectableStreamMyResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStreamCombo")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.MyResponse, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.CorrectableStreamCombo(ctx, nodeArg, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *MyResponse
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamComboQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStreamCombo(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStreamCombo(ctx, in)
	if err != nil {
		replyChan <- internalResponse{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalResponse{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// CorrectableEmpty for testing imported message type.
func (c *Configuration) CorrectableStreamEmpty(ctx context.Context, in *Request, opts ...grpc.CallOption) *CorrectableStreamEmpty {
	corr := &CorrectableStreamEmpty{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStreamEmpty(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableStreamEmpty(ctx context.Context, in *Request, resp *CorrectableStreamEmpty, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStreamEmpty")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Empty, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalEmpty, expected)
	for _, n := range c.nodes {
		go n.CorrectableStreamEmpty(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*empty.Empty, c.n*2)
		clevel  = LevelNotSet
		reply   *empty.Empty
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamEmptyQF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStreamEmpty(ctx context.Context, in *Request, replyChan chan<- internalEmpty) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStreamEmpty(ctx, in)
	if err != nil {
		replyChan <- internalEmpty{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalEmpty{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// CorrectableEmpty2 for testing imported message type; with same return
// type as Correctable: Response.
func (c *Configuration) CorrectableStreamEmpty2(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) *CorrectableStreamResponse {
	corr := &CorrectableStreamResponse{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go c.correctableStreamEmpty2(ctx, in, corr, opts...)
	return corr
}

func (c *Configuration) correctableStreamEmpty2(ctx context.Context, in *empty.Empty, resp *CorrectableStreamResponse, opts ...grpc.CallOption) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "CorrectableStreamEmpty2")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{ids: resp.NodeIDs, reply: resp.Response, err: resp.err}, false)
			if resp.err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.CorrectableStreamEmpty2(ctx, in, replyChan)
	}

	var (
		replies = make(map[uint32]*Response, c.n*2)
		clevel  = LevelNotSet
		reply   *Response
		rlevel  int
		errs    []GRPCError
		quorum  bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = appendIfNotPresent(resp.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			reply, rlevel, quorum = c.qspec.CorrectableStreamEmpty2QF(in, replies)
			if quorum {
				resp.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				resp.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			resp.set(reply, clevel, QuorumCallError{ctx.Err().Error(), len(replies), errs}, true)
			return
		}
		if len(errs) == expected { // Can't rely on reply count.
			resp.set(reply, clevel, QuorumCallError{"incomplete call", len(replies), errs}, true)
			return
		}
	}
}

func (n *Node) CorrectableStreamEmpty2(ctx context.Context, in *empty.Empty, replyChan chan<- internalResponse) {
	x := NewZorumsServiceClient(n.conn)
	y, err := x.CorrectableStreamEmpty2(ctx, in)
	if err != nil {
		replyChan <- internalResponse{n.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- internalResponse{n.id, reply, err}
		if err != nil {
			return
		}
	}
}

// Multicast plain. Response type is not needed here.
func (c *Configuration) Multicast(in *Request) error {
	msgID := c.mgr.nextMsgID()
	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  multicastMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	for _, n := range c.nodes {
		n.sendQ <- msg
	}
	return nil
}

// MulticastPerNodeArg with per_node_arg option.
func (c *Configuration) MulticastPerNodeArg(in *Request, f func(*Request, uint32) *Request) error {
	msgID := c.mgr.nextMsgID()
	for _, n := range c.nodes {
		nodeArg := f(in, n.ID())
		if nodeArg == nil {
			continue
		}
		metadata := &ordering.Metadata{
			MessageID: msgID,
			MethodID:  multicastPerNodeArgMethodID,
		}
		msg := &gorumsMessage{metadata: metadata, message: nodeArg}
		n.sendQ <- msg
	}
	return nil
}

// Multicast2 is testing whether multiple streams work.
func (c *Configuration) Multicast2(in *Request) error {
	msgID := c.mgr.nextMsgID()
	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  multicast2MethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	for _, n := range c.nodes {
		n.sendQ <- msg
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ empty.Empty

// Multicast3 is testing imported message type.
func (c *Configuration) Multicast3(in *Request) error {
	msgID := c.mgr.nextMsgID()
	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  multicast3MethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	for _, n := range c.nodes {
		n.sendQ <- msg
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ empty.Empty

// Multicast4 is testing imported message type.
func (c *Configuration) Multicast4(in *empty.Empty) error {
	msgID := c.mgr.nextMsgID()
	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  multicast4MethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	for _, n := range c.nodes {
		n.sendQ <- msg
	}
	return nil
}

type nodeServices struct {
	ZorumsServiceClient
	multicastClient           ZorumsService_MulticastClient
	multicastPerNodeArgClient ZorumsService_MulticastPerNodeArgClient
	multicast2Client          ZorumsService_Multicast2Client
	multicast3Client          ZorumsService_Multicast3Client
	multicast4Client          ZorumsService_Multicast4Client
}

func (n *Node) connectStream(ctx context.Context) (err error) {

	n.ZorumsServiceClient = NewZorumsServiceClient(n.conn)

	n.multicastClient, err = n.ZorumsServiceClient.Multicast(ctx)
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}
	n.multicastPerNodeArgClient, err = n.ZorumsServiceClient.MulticastPerNodeArg(ctx)
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}
	n.multicast2Client, err = n.ZorumsServiceClient.Multicast2(ctx)
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}
	n.multicast3Client, err = n.ZorumsServiceClient.Multicast3(ctx)
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}
	n.multicast4Client, err = n.ZorumsServiceClient.Multicast4(ctx)
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}
	return nil
}

func (n *Node) closeStream() (err error) {
	_, err = n.multicastClient.CloseAndRecv()
	_, err = n.multicastPerNodeArgClient.CloseAndRecv()
	_, err = n.multicast2Client.CloseAndRecv()
	_, err = n.multicast3Client.CloseAndRecv()
	_, err = n.multicast4Client.CloseAndRecv()
	return err
}

// OrderingQC is a quorum call invoked on all nodes in configuration c,
// with the same argument in, and returns a combined result.
func (c *Configuration) OrderingQC(ctx context.Context, in *Request) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "OrderingQC")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	// remove the replies channel when we are done
	defer c.mgr.deleteChan(msgID)

	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  orderingQCMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	// push the message to the nodes
	expected := c.n
	for _, n := range c.nodes {
		n.sendQ <- msg
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			reply := r.reply.(*Response)
			replies[r.nid] = reply
			if resp, quorum = c.qspec.OrderingQCQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}

		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

// OrderingPerNodeArg is a quorum call invoked on each node in configuration c,
// with the argument returned by the provided function f, and returns the combined result.
// The per node function f receives a copy of the Request request argument and
// returns a Request manipulated to be passed to the given nodeID.
// The function f must be thread-safe.
func (c *Configuration) OrderingPerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "OrderingPerNodeArg")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	// remove the replies channel when we are done
	defer c.mgr.deleteChan(msgID)

	// push the message to the nodes
	expected := c.n
	for _, n := range c.nodes {
		nodeArg := f(in, n.ID())
		if nodeArg == nil {
			expected--
			continue
		}
		metadata := &ordering.Metadata{
			MessageID: msgID,
			MethodID:  orderingPerNodeArgMethodID,
		}
		msg := &gorumsMessage{metadata: metadata, message: nodeArg}
		n.sendQ <- msg
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			reply := r.reply.(*Response)
			replies[r.nid] = reply
			if resp, quorum = c.qspec.OrderingPerNodeArgQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}

		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

// OrderingCustomReturnType is a quorum call invoked on all nodes in configuration c,
// with the same argument in, and returns a combined result.
func (c *Configuration) OrderingCustomReturnType(ctx context.Context, in *Request) (resp *MyResponse, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "OrderingCustomReturnType")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	// remove the replies channel when we are done
	defer c.mgr.deleteChan(msgID)

	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  orderingCustomReturnTypeMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	// push the message to the nodes
	expected := c.n
	for _, n := range c.nodes {
		n.sendQ <- msg
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			reply := r.reply.(*Response)
			replies[r.nid] = reply
			if resp, quorum = c.qspec.OrderingCustomReturnTypeQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}

		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

// OrderingCombo is a quorum call invoked on each node in configuration c,
// with the argument returned by the provided function f, and returns the combined result.
// The per node function f receives a copy of the Request request argument and
// returns a Request manipulated to be passed to the given nodeID.
// The function f must be thread-safe.
func (c *Configuration) OrderingCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request) (resp *MyResponse, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "OrderingCombo")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	// remove the replies channel when we are done
	defer c.mgr.deleteChan(msgID)

	// push the message to the nodes
	expected := c.n
	for _, n := range c.nodes {
		nodeArg := f(in, n.ID())
		if nodeArg == nil {
			expected--
			continue
		}
		metadata := &ordering.Metadata{
			MessageID: msgID,
			MethodID:  orderingComboMethodID,
		}
		msg := &gorumsMessage{metadata: metadata, message: nodeArg}
		n.sendQ <- msg
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			reply := r.reply.(*Response)
			replies[r.nid] = reply
			if resp, quorum = c.qspec.OrderingComboQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}

		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) OrderingUnaryRPC(ctx context.Context, in *Request, opts ...grpc.CallOption) (resp *Response, err error) {

	// get the ID which will be used to return the correct responses for a request
	msgID := n.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, 1)
	n.putChan(msgID, replyChan)

	// remove the replies channel when we are done
	defer n.deleteChan(msgID)

	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  orderingUnaryRPCMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}
	n.sendQ <- msg

	select {
	case r := <-replyChan:
		if r.err != nil {
			return nil, r.err
		}
		reply := r.reply.(*Response)
		return reply, nil
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// OrderingFuture asynchronously invokes a quorum call on configuration c
// and returns a FutureResponse, which can be used to inspect the quorum call
// reply and error when available.
func (c *Configuration) OrderingFuture(ctx context.Context, in *Request) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	expected := c.n

	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  orderingFutureMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}

	// push the message to the nodes
	for _, n := range c.nodes {
		n.sendQ <- msg
	}

	go c.orderingFutureRecv(ctx, in, msgID, expected, replyChan, fut)

	return fut
}

func (c *Configuration) orderingFutureRecv(ctx context.Context, in *Request, msgID uint64, expected int, replyChan chan *orderingResult, fut *FutureResponse) {
	defer close(fut.c)

	if fut.err != nil {
		return
	}

	defer c.mgr.deleteChan(msgID)

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			fut.NodeIDs = append(fut.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			data := r.reply.(*Response)
			replies[r.nid] = data
			if reply, quorum = c.qspec.OrderingFutureQF(in, replies); quorum {
				fut.Response, fut.err = reply, nil
				return
			}
		case <-ctx.Done():
			fut.Response, fut.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			fut.Response, fut.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

// OrderingFuturePerNodeArg asynchronously invokes a quorum call on each node in
// configuration c, with the argument returned by the provided function f
// and returns the result as a FutureResponse, which can be used to inspect
// the quorum call reply and error when available.
// The provide per node function f takes the provided Request argument
// and returns an Response object to be passed to the given nodeID.
// The per node function f should be thread-safe.
func (c *Configuration) OrderingFuturePerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request) *FutureResponse {
	fut := &FutureResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	expected := c.n

	// push the message to the nodes
	for _, n := range c.nodes {
		nodeArg := f(in, n.ID())
		if nodeArg == nil {
			expected--
			continue
		}
		metadata := &ordering.Metadata{
			MessageID: msgID,
			MethodID:  orderingFuturePerNodeArgMethodID,
		}
		msg := &gorumsMessage{metadata: metadata, message: nodeArg}
		n.sendQ <- msg
	}

	go c.orderingFuturePerNodeArgRecv(ctx, in, msgID, expected, replyChan, fut)

	return fut
}

func (c *Configuration) orderingFuturePerNodeArgRecv(ctx context.Context, in *Request, msgID uint64, expected int, replyChan chan *orderingResult, fut *FutureResponse) {
	defer close(fut.c)

	if fut.err != nil {
		return
	}

	defer c.mgr.deleteChan(msgID)

	var (
		reply   *Response
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			fut.NodeIDs = append(fut.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			data := r.reply.(*Response)
			replies[r.nid] = data
			if reply, quorum = c.qspec.OrderingFuturePerNodeArgQF(in, replies); quorum {
				fut.Response, fut.err = reply, nil
				return
			}
		case <-ctx.Done():
			fut.Response, fut.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			fut.Response, fut.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

// OrderingFutureCustomReturnType asynchronously invokes a quorum call on configuration c
// and returns a FutureMyResponse, which can be used to inspect the quorum call
// reply and error when available.
func (c *Configuration) OrderingFutureCustomReturnType(ctx context.Context, in *Request) *FutureMyResponse {
	fut := &FutureMyResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	expected := c.n

	metadata := &ordering.Metadata{
		MessageID: msgID,
		MethodID:  orderingFutureCustomReturnTypeMethodID,
	}
	msg := &gorumsMessage{metadata: metadata, message: in}

	// push the message to the nodes
	for _, n := range c.nodes {
		n.sendQ <- msg
	}

	go c.orderingFutureCustomReturnTypeRecv(ctx, in, msgID, expected, replyChan, fut)

	return fut
}

func (c *Configuration) orderingFutureCustomReturnTypeRecv(ctx context.Context, in *Request, msgID uint64, expected int, replyChan chan *orderingResult, fut *FutureMyResponse) {
	defer close(fut.c)

	if fut.err != nil {
		return
	}

	defer c.mgr.deleteChan(msgID)

	var (
		reply   *MyResponse
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			fut.NodeIDs = append(fut.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			data := r.reply.(*Response)
			replies[r.nid] = data
			if reply, quorum = c.qspec.OrderingFutureCustomReturnTypeQF(in, replies); quorum {
				fut.MyResponse, fut.err = reply, nil
				return
			}
		case <-ctx.Done():
			fut.MyResponse, fut.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			fut.MyResponse, fut.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

// OrderingFutureCombo asynchronously invokes a quorum call on each node in
// configuration c, with the argument returned by the provided function f
// and returns the result as a FutureMyResponse, which can be used to inspect
// the quorum call reply and error when available.
// The provide per node function f takes the provided Request argument
// and returns an Response object to be passed to the given nodeID.
// The per node function f should be thread-safe.
func (c *Configuration) OrderingFutureCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request) *FutureMyResponse {
	fut := &FutureMyResponse{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	// get the ID which will be used to return the correct responses for a request
	msgID := c.mgr.nextMsgID()

	// set up a channel to collect replies
	replyChan := make(chan *orderingResult, c.n)
	c.mgr.putChan(msgID, replyChan)

	expected := c.n

	// push the message to the nodes
	for _, n := range c.nodes {
		nodeArg := f(in, n.ID())
		if nodeArg == nil {
			expected--
			continue
		}
		metadata := &ordering.Metadata{
			MessageID: msgID,
			MethodID:  orderingFutureComboMethodID,
		}
		msg := &gorumsMessage{metadata: metadata, message: nodeArg}
		n.sendQ <- msg
	}

	go c.orderingFutureComboRecv(ctx, in, msgID, expected, replyChan, fut)

	return fut
}

func (c *Configuration) orderingFutureComboRecv(ctx context.Context, in *Request, msgID uint64, expected int, replyChan chan *orderingResult, fut *FutureMyResponse) {
	defer close(fut.c)

	if fut.err != nil {
		return
	}

	defer c.mgr.deleteChan(msgID)

	var (
		reply   *MyResponse
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response, 2*c.n)
	)

	for {
		select {
		case r := <-replyChan:
			fut.NodeIDs = append(fut.NodeIDs, r.nid)
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			data := r.reply.(*Response)
			replies[r.nid] = data
			if reply, quorum = c.qspec.OrderingFutureComboQF(in, replies); quorum {
				fut.MyResponse, fut.err = reply, nil
				return
			}
		case <-ctx.Done():
			fut.MyResponse, fut.err = reply, QuorumCallError{ctx.Err().Error(), len(replies), errs}
			return
		}
		if len(errs)+len(replies) == expected {
			fut.MyResponse, fut.err = reply, QuorumCallError{"incomplete call", len(replies), errs}
			return
		}
	}
}

// QuorumSpec is the interface of quorum functions for ZorumsService.
type QuorumSpec interface {

	// QuorumCallQF is the quorum function for the QuorumCall
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCall method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallPerNodeArgQF is the quorum function for the QuorumCallPerNodeArg
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCallPerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallPerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallCustomReturnTypeQF is the quorum function for the QuorumCallCustomReturnType
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCallCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// QuorumCallComboQF is the quorum function for the QuorumCallCombo
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCallCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// QuorumCallEmptyQF is the quorum function for the QuorumCallEmpty
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCallEmpty method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *empty.Empty'.
	QuorumCallEmptyQF(in *empty.Empty, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallEmpty2QF is the quorum function for the QuorumCallEmpty2
	// quorum call method. The in parameter is the request object
	// supplied to the QuorumCallEmpty2 method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallEmpty2QF(in *Request, replies map[uint32]*empty.Empty) (*empty.Empty, bool)

	// QuorumCallFutureQF is the quorum function for the QuorumCallFuture
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFuture method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFutureQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallFuturePerNodeArgQF is the quorum function for the QuorumCallFuturePerNodeArg
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFuturePerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFuturePerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallFutureCustomReturnTypeQF is the quorum function for the QuorumCallFutureCustomReturnType
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFutureCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFutureCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// QuorumCallFutureComboQF is the quorum function for the QuorumCallFutureCombo
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFutureCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFutureComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// QuorumCallFuture2QF is the quorum function for the QuorumCallFuture2
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFuture2 method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFuture2QF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// QuorumCallFutureEmptyQF is the quorum function for the QuorumCallFutureEmpty
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFutureEmpty method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	QuorumCallFutureEmptyQF(in *Request, replies map[uint32]*empty.Empty) (*empty.Empty, bool)

	// QuorumCallFutureEmpty2QF is the quorum function for the QuorumCallFutureEmpty2
	// asynchronous quorum call method. The in parameter is the request object
	// supplied to the QuorumCallFutureEmpty2 method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *empty.Empty'.
	QuorumCallFutureEmpty2QF(in *empty.Empty, replies map[uint32]*Response) (*Response, bool)

	// CorrectableQF is the quorum function for the Correctable
	// correctable quorum call method. The in parameter is the request object
	// supplied to the Correctable method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableQF(in *Request, replies map[uint32]*Response) (*Response, int, bool)

	// CorrectablePerNodeArgQF is the quorum function for the CorrectablePerNodeArg
	// correctable quorum call method. The in parameter is the request object
	// supplied to the CorrectablePerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectablePerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, int, bool)

	// CorrectableCustomReturnTypeQF is the quorum function for the CorrectableCustomReturnType
	// correctable quorum call method. The in parameter is the request object
	// supplied to the CorrectableCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, int, bool)

	// CorrectableComboQF is the quorum function for the CorrectableCombo
	// correctable quorum call method. The in parameter is the request object
	// supplied to the CorrectableCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, int, bool)

	// CorrectableEmptyQF is the quorum function for the CorrectableEmpty
	// correctable quorum call method. The in parameter is the request object
	// supplied to the CorrectableEmpty method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableEmptyQF(in *Request, replies map[uint32]*empty.Empty) (*empty.Empty, int, bool)

	// CorrectableEmpty2QF is the quorum function for the CorrectableEmpty2
	// correctable quorum call method. The in parameter is the request object
	// supplied to the CorrectableEmpty2 method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *empty.Empty'.
	CorrectableEmpty2QF(in *empty.Empty, replies map[uint32]*Response) (*Response, int, bool)

	// CorrectableStreamQF is the quorum function for the CorrectableStream
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStream method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableStreamQF(in *Request, replies map[uint32]*Response) (*Response, int, bool)

	// CorrectableStreamPerNodeArgQF is the quorum function for the CorrectableStreamPerNodeArg
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStreamPerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableStreamPerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, int, bool)

	// CorrectableStreamCustomReturnTypeQF is the quorum function for the CorrectableStreamCustomReturnType
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStreamCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableStreamCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, int, bool)

	// CorrectableStreamComboQF is the quorum function for the CorrectableStreamCombo
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStreamCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableStreamComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, int, bool)

	// CorrectableStreamEmptyQF is the quorum function for the CorrectableStreamEmpty
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStreamEmpty method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	CorrectableStreamEmptyQF(in *Request, replies map[uint32]*empty.Empty) (*empty.Empty, int, bool)

	// CorrectableStreamEmpty2QF is the quorum function for the CorrectableStreamEmpty2
	// correctable stream quorum call method. The in parameter is the request object
	// supplied to the CorrectableStreamEmpty2 method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *empty.Empty'.
	CorrectableStreamEmpty2QF(in *empty.Empty, replies map[uint32]*Response) (*Response, int, bool)

	// OrderingQCQF is the quorum function for the OrderingQC
	// ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingQC method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingQCQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// OrderingPerNodeArgQF is the quorum function for the OrderingPerNodeArg
	// ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingPerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingPerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// OrderingCustomReturnTypeQF is the quorum function for the OrderingCustomReturnType
	// ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// OrderingComboQF is the quorum function for the OrderingCombo
	// ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// OrderingFutureQF is the quorum function for the OrderingFuture
	// asynchronous ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingFuture method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingFutureQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// OrderingFuturePerNodeArgQF is the quorum function for the OrderingFuturePerNodeArg
	// asynchronous ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingFuturePerNodeArg method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingFuturePerNodeArgQF(in *Request, replies map[uint32]*Response) (*Response, bool)

	// OrderingFutureCustomReturnTypeQF is the quorum function for the OrderingFutureCustomReturnType
	// asynchronous ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingFutureCustomReturnType method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingFutureCustomReturnTypeQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)

	// OrderingFutureComboQF is the quorum function for the OrderingFutureCombo
	// asynchronous ordered quorum call method. The in parameter is the request object
	// supplied to the OrderingFutureCombo method at call time, and may or may not
	// be used by the quorum function. If the in parameter is not needed
	// you should implement your quorum function with '_ *Request'.
	OrderingFutureComboQF(in *Request, replies map[uint32]*Response) (*MyResponse, bool)
}

// QuorumCall plain.
func (c *Configuration) QuorumCall(ctx context.Context, in *Request, opts ...grpc.CallOption) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCall")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCall(ctx, in, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCall(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCall", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCall with per_node_arg option.
func (c *Configuration) QuorumCallPerNodeArg(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallPerNodeArg")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.QuorumCallPerNodeArg(ctx, nodeArg, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallPerNodeArgQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCallPerNodeArg(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallPerNodeArg", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCall with custom_return_type option.
func (c *Configuration) QuorumCallCustomReturnType(ctx context.Context, in *Request, opts ...grpc.CallOption) (resp *MyResponse, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallCustomReturnType")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallCustomReturnType(ctx, in, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallCustomReturnTypeQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCallCustomReturnType(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallCustomReturnType", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallCombo with all supported options.
func (c *Configuration) QuorumCallCombo(ctx context.Context, in *Request, f func(*Request, uint32) *Request, opts ...grpc.CallOption) (resp *MyResponse, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallCombo")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		nodeArg := f(in, n.id)
		if nodeArg == nil {
			expected--
			continue
		}
		go n.QuorumCallCombo(ctx, nodeArg, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallComboQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCallCombo(ctx context.Context, in *Request, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallCombo", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallEmpty for testing imported message type.
func (c *Configuration) QuorumCallEmpty(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallEmpty")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go n.QuorumCallEmpty(ctx, in, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*Response)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallEmptyQF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCallEmpty(ctx context.Context, in *empty.Empty, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallEmpty", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalResponse{n.id, reply, err}
}

// QuorumCallEmpty2 for testing imported message type.
func (c *Configuration) QuorumCallEmpty2(ctx context.Context, in *Request, opts ...grpc.CallOption) (resp *empty.Empty, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.String()+".Sent", "QuorumCallEmpty2")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = time.Until(deadline)
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: in}, false)

		defer func() {
			ti.LazyLog(&qcresult{reply: resp, err: err}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalEmpty, expected)
	for _, n := range c.nodes {
		go n.QuorumCallEmpty2(ctx, in, replyChan)
	}

	var (
		errs    []GRPCError
		quorum  bool
		replies = make(map[uint32]*empty.Empty)
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}

			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}

			replies[r.nid] = r.reply
			if resp, quorum = c.qspec.QuorumCallEmpty2QF(in, replies); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replies), errs}
		}
		if len(errs)+len(replies) == expected {
			return resp, QuorumCallError{"incomplete call", len(replies), errs}
		}
	}
}

func (n *Node) QuorumCallEmpty2(ctx context.Context, in *Request, replyChan chan<- internalEmpty) {
	reply := new(empty.Empty)
	start := time.Now()
	err := n.conn.Invoke(ctx, "/gorums.testprotos.calltypes.zorums.ZorumsService/QuorumCallEmpty2", in, reply)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		n.setLatency(time.Since(start))
	} else {
		n.setLastErr(err)
	}
	replyChan <- internalEmpty{n.id, reply, err}
}

// ZorumsService is the server-side API for the ZorumsService Service
type ZorumsService interface {
	Multicast(*Request)
	MulticastPerNodeArg(*Request)
	Multicast2(*Request)
	Multicast3(*Request)
	Multicast4(*empty.Empty)
	OrderingQC(*Request, chan<- *Response)
	OrderingPerNodeArg(*Request, chan<- *Response)
	OrderingCustomReturnType(*Request, chan<- *Response)
	OrderingCombo(*Request, chan<- *Response)
	OrderingUnaryRPC(*Request, chan<- *Response)
	OrderingFuture(*Request, chan<- *Response)
	OrderingFuturePerNodeArg(*Request, chan<- *Response)
	OrderingFutureCustomReturnType(*Request, chan<- *Response)
	OrderingFutureCombo(*Request, chan<- *Response)
}

func (s *GorumsServer) RegisterZorumsServiceServer(srv ZorumsService) {
	s.srv.handlers[multicastMethodID] = func(in *gorumsMessage, _ chan<- *gorumsMessage) {
		req := in.message.(*Request)
		srv.Multicast(req)
	}
	s.srv.handlers[multicastPerNodeArgMethodID] = func(in *gorumsMessage, _ chan<- *gorumsMessage) {
		req := in.message.(*Request)
		srv.MulticastPerNodeArg(req)
	}
	s.srv.handlers[multicast2MethodID] = func(in *gorumsMessage, _ chan<- *gorumsMessage) {
		req := in.message.(*Request)
		srv.Multicast2(req)
	}
	s.srv.handlers[multicast3MethodID] = func(in *gorumsMessage, _ chan<- *gorumsMessage) {
		req := in.message.(*Request)
		srv.Multicast3(req)
	}
	s.srv.handlers[multicast4MethodID] = func(in *gorumsMessage, _ chan<- *gorumsMessage) {
		req := in.message.(*empty.Empty)
		srv.Multicast4(req)
	}
	s.srv.handlers[orderingQCMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingQC(req, c)
	}
	s.srv.handlers[orderingPerNodeArgMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingPerNodeArg(req, c)
	}
	s.srv.handlers[orderingCustomReturnTypeMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingCustomReturnType(req, c)
	}
	s.srv.handlers[orderingComboMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingCombo(req, c)
	}
	s.srv.handlers[orderingUnaryRPCMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingUnaryRPC(req, c)
	}
	s.srv.handlers[orderingFutureMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingFuture(req, c)
	}
	s.srv.handlers[orderingFuturePerNodeArgMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingFuturePerNodeArg(req, c)
	}
	s.srv.handlers[orderingFutureCustomReturnTypeMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingFutureCustomReturnType(req, c)
	}
	s.srv.handlers[orderingFutureComboMethodID] = func(in *gorumsMessage, finished chan<- *gorumsMessage) {
		req := in.message.(*Request)
		c := make(chan *Response)
		go func() {
			resp := <-c
			finished <- &gorumsMessage{metadata: in.metadata, message: resp}
		}()
		srv.OrderingFutureCombo(req, c)
	}
}

const hasOrderingMethods = true

const multicastMethodID int32 = 0
const multicastPerNodeArgMethodID int32 = 1
const multicast2MethodID int32 = 2
const multicast3MethodID int32 = 3
const multicast4MethodID int32 = 4
const orderingQCMethodID int32 = 5
const orderingPerNodeArgMethodID int32 = 6
const orderingCustomReturnTypeMethodID int32 = 7
const orderingComboMethodID int32 = 8
const orderingUnaryRPCMethodID int32 = 9
const orderingFutureMethodID int32 = 10
const orderingFuturePerNodeArgMethodID int32 = 11
const orderingFutureCustomReturnTypeMethodID int32 = 12
const orderingFutureComboMethodID int32 = 13

var orderingMethods = map[int32]methodInfo{

	0:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	1:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	2:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	3:  {requestType: new(Request).ProtoReflect(), responseType: new(empty.Empty).ProtoReflect()},
	4:  {requestType: new(empty.Empty).ProtoReflect(), responseType: new(empty.Empty).ProtoReflect()},
	5:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	6:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	7:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	8:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	9:  {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	10: {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	11: {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	12: {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
	13: {requestType: new(Request).ProtoReflect(), responseType: new(Response).ProtoReflect()},
}

type internalEmpty struct {
	nid   uint32
	reply *empty.Empty
	err   error
}

type internalResponse struct {
	nid   uint32
	reply *Response
	err   error
}

// FutureEmpty is a future object for processing replies.
type FutureEmpty struct {
	// the actual reply
	*empty.Empty
	NodeIDs []uint32
	err     error
	c       chan struct{}
}

// Get returns the reply and any error associated with the called method.
// The method blocks until a reply or error is available.
func (f *FutureEmpty) Get() (*empty.Empty, error) {
	<-f.c
	return f.Empty, f.err
}

// Done reports if a reply and/or error is available for the called method.
func (f *FutureEmpty) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

// FutureMyResponse is a future object for processing replies.
type FutureMyResponse struct {
	// the actual reply
	*MyResponse
	NodeIDs []uint32
	err     error
	c       chan struct{}
}

// Get returns the reply and any error associated with the called method.
// The method blocks until a reply or error is available.
func (f *FutureMyResponse) Get() (*MyResponse, error) {
	<-f.c
	return f.MyResponse, f.err
}

// Done reports if a reply and/or error is available for the called method.
func (f *FutureMyResponse) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

// FutureResponse is a future object for processing replies.
type FutureResponse struct {
	// the actual reply
	*Response
	NodeIDs []uint32
	err     error
	c       chan struct{}
}

// Get returns the reply and any error associated with the called method.
// The method blocks until a reply or error is available.
func (f *FutureResponse) Get() (*Response, error) {
	<-f.c
	return f.Response, f.err
}

// Done reports if a reply and/or error is available for the called method.
func (f *FutureResponse) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

// CorrectableEmpty is a correctable object for processing replies.
type CorrectableEmpty struct {
	mu sync.Mutex
	// the actual reply
	*empty.Empty
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableEmpty) Get() (*empty.Empty, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.Empty, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableEmpty) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableEmpty) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableEmpty) set(reply *empty.Empty, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.Empty, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}

// CorrectableMyResponse is a correctable object for processing replies.
type CorrectableMyResponse struct {
	mu sync.Mutex
	// the actual reply
	*MyResponse
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableMyResponse) Get() (*MyResponse, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.MyResponse, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableMyResponse) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableMyResponse) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableMyResponse) set(reply *MyResponse, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.MyResponse, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}

// CorrectableResponse is a correctable object for processing replies.
type CorrectableResponse struct {
	mu sync.Mutex
	// the actual reply
	*Response
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableResponse) Get() (*Response, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.Response, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableResponse) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableResponse) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableResponse) set(reply *Response, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.Response, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}

// CorrectableStreamEmpty is a correctable object for processing replies.
type CorrectableStreamEmpty struct {
	mu sync.Mutex
	// the actual reply
	*empty.Empty
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableStreamEmpty) Get() (*empty.Empty, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.Empty, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableStreamEmpty) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableStreamEmpty) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableStreamEmpty) set(reply *empty.Empty, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.Empty, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}

// CorrectableStreamMyResponse is a correctable object for processing replies.
type CorrectableStreamMyResponse struct {
	mu sync.Mutex
	// the actual reply
	*MyResponse
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableStreamMyResponse) Get() (*MyResponse, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.MyResponse, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableStreamMyResponse) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableStreamMyResponse) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableStreamMyResponse) set(reply *MyResponse, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.MyResponse, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}

// CorrectableStreamResponse is a correctable object for processing replies.
type CorrectableStreamResponse struct {
	mu sync.Mutex
	// the actual reply
	*Response
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// Get returns the reply, level and any error associated with the
// called method. The method does not block until a (possibly
// intermediate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *CorrectableStreamResponse) Get() (*Response, int, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.Response, c.level, c.err
}

// Done returns a channel that will be closed when the correctable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or the call returned an error.
func (c *CorrectableStreamResponse) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that will be closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// regardless of the specified level.
func (c *CorrectableStreamResponse) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.mu.Lock()
	defer c.mu.Unlock()
	if level < c.level {
		close(ch)
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	return ch
}

func (c *CorrectableStreamResponse) set(reply *Response, level int, err error, done bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.done {
		panic("set(...) called on a done correctable")
	}
	c.Response, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
}
