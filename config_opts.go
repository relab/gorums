package gorums

import (
	"cmp"
	"fmt"
)

// ConfigOption is a marker interface for options to NewConfiguration.
type ConfigOption interface{}

// NodeListOption must be implemented by node providers.
type NodeListOption[idType cmp.Ordered] interface {
	ConfigOption
	newConfig(*RawManager[idType]) (RawConfiguration[idType], error)
}

type nodeIDMap[idType cmp.Ordered] struct {
	idMap map[string]idType
}

func (o nodeIDMap[idType]) newConfig(mgr *RawManager[idType]) (nodes RawConfiguration[idType], err error) {
	if len(o.idMap) == 0 {
		return nil, fmt.Errorf("config: missing required node map")
	}
	nodes = make(RawConfiguration[idType], 0, len(o.idMap))
	for naddr, id := range o.idMap {
		node, found := mgr.Node(id)
		if !found {
			node, err = NewRawNodeWithID(naddr, id)
			if err != nil {
				return nil, err
			}
			if err = mgr.AddNode(node); err != nil {
				return nil, err
			}
		}
		nodes = append(nodes, node)

	}

	// Sort nodes to ensure deterministic iteration.
	OrderedBy[idType](ID).Sort(mgr.nodes)
	OrderedBy[idType](ID).Sort(nodes)

	return nodes, nil
}

// WithNodeMap returns a NodeListOption containing the provided
// mapping from node addresses to application-specific IDs.
func WithNodeMap[idType cmp.Ordered](idMap map[string]idType) NodeListOption[idType] {
	return &nodeIDMap[idType]{idMap: idMap}
}

type nodeList[idType uint32 | int32] struct {
	addrsList []string
}

func (o nodeList[idType]) newConfig(mgr *RawManager[idType]) (nodes RawConfiguration[idType], err error) {
	if len(o.addrsList) == 0 {
		return nil, fmt.Errorf("config: missing required node addresses")
	}
	nodes = make(RawConfiguration[idType], 0, len(o.addrsList))
	for _, naddr := range o.addrsList {
		fmt.Printf("addr: %s\n", naddr)
		node, err := NewRawNode[idType](naddr)
		fmt.Println(node.ID())
		if err != nil {
			return nil, err
		}
		if n, found := mgr.Node(node.ID()); !found {
			if err = mgr.AddNode(node); err != nil {
				return nil, err
			}
		} else {
			node = n
		}
		fmt.Println(node)
		nodes = append(nodes, node)
		fmt.Println(nodes.Nodes())
	}
	fmt.Println(nodes.Nodes())
	// Sort nodes to ensure deterministic iteration.
	OrderedBy[idType](ID).Sort(mgr.nodes)
	OrderedBy[idType](ID).Sort(nodes)
	fmt.Println(nodes.Nodes())
	return nodes, nil
}

// WithNodeList returns a NodeListOption containing the provided list of node addresses.
// With this option, node IDs are generated by the Manager.
func WithNodeList[idType int32 | uint32](addrsList []string) NodeListOption[idType] {
	return &nodeList[idType]{addrsList: addrsList}
}

type nodeIDs[idType cmp.Ordered] struct {
	nodeIDs []idType
}

func (o nodeIDs[idType]) newConfig(mgr *RawManager[idType]) (nodes RawConfiguration[idType], err error) {
	if len(o.nodeIDs) == 0 {
		return nil, fmt.Errorf("config: missing required node IDs")
	}
	nodes = make(RawConfiguration[idType], 0, len(o.nodeIDs))
	for _, id := range o.nodeIDs {
		node, found := mgr.Node(id)
		if !found {
			// Node IDs must have been registered previously
			return nil, fmt.Errorf("config: node %v not found", id)
		}
		nodes = append(nodes, node)
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy[idType](ID).Sort(mgr.nodes)
	OrderedBy[idType](ID).Sort(nodes)
	return nodes, nil
}

// WithNodeIDs returns a NodeListOption containing a list of node IDs.
// This assumes that the provided node IDs have already been registered with the manager.
func WithNodeIDs[idType cmp.Ordered](ids []idType) NodeListOption[idType] {
	return &nodeIDs[idType]{nodeIDs: ids}
}

type addNodes[idType cmp.Ordered] struct {
	old RawConfiguration[idType]
	new NodeListOption[idType]
}

func (o addNodes[idType]) newConfig(mgr *RawManager[idType]) (nodes RawConfiguration[idType], err error) {
	newNodes, err := o.new.newConfig(mgr)
	if err != nil {
		return nil, err
	}
	ac := &addConfig[idType]{old: o.old, add: newNodes}
	return ac.newConfig(mgr)
}

// WithNewNodes returns a NodeListOption that can be used to create a new configuration
// combining c and the new nodes.
func (c RawConfiguration[idType]) WithNewNodes(new NodeListOption[idType]) NodeListOption[idType] {
	return &addNodes[idType]{old: c, new: new}
}

type addConfig[idType cmp.Ordered] struct {
	old RawConfiguration[idType]
	add RawConfiguration[idType]
}

func (o addConfig[idType]) newConfig(mgr *RawManager[idType]) (nodes RawConfiguration[idType], err error) {
	nodes = make(RawConfiguration[idType], 0, len(o.old)+len(o.add))
	m := make(map[idType]bool)
	for _, n := range append(o.old, o.add...) {
		if !m[n.id] {
			m[n.id] = true
			nodes = append(nodes, n)
		}
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy[idType](ID).Sort(mgr.nodes)
	OrderedBy[idType](ID).Sort(nodes)
	return nodes, err
}

// And returns a NodeListOption that can be used to create a new configuration combining c and d.
func (c RawConfiguration[idType]) And(d RawConfiguration[idType]) NodeListOption[idType] {
	return &addConfig[idType]{old: c, add: d}
}

// WithoutNodes returns a NodeListOption that can be used to create a new configuration
// from c without the given node IDs.
func (c RawConfiguration[idType]) WithoutNodes(ids ...idType) NodeListOption[idType] {
	rmIDs := make(map[idType]bool)
	for _, id := range ids {
		rmIDs[id] = true
	}
	keepIDs := make([]idType, 0, len(c))
	for _, cNode := range c {
		if !rmIDs[cNode.id] {
			keepIDs = append(keepIDs, cNode.id)
		}
	}
	return &nodeIDs[idType]{nodeIDs: keepIDs}
}

// Except returns a NodeListOption that can be used to create a new configuration
// from c without the nodes in rm.
func (c RawConfiguration[idType]) Except(rm RawConfiguration[idType]) NodeListOption[idType] {
	rmIDs := make(map[idType]bool)
	for _, rmNode := range rm {
		rmIDs[rmNode.id] = true
	}
	keepIDs := make([]idType, 0, len(c))
	for _, cNode := range c {
		if !rmIDs[cNode.id] {
			keepIDs = append(keepIDs, cNode.id)
		}
	}
	return &nodeIDs[idType]{nodeIDs: keepIDs}
}
