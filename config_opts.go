package gorums

import (
	"errors"
	"fmt"
)

// NodeListOption must be implemented by node providers.
type NodeListOption[T NodeID] interface {
	Option
	newConfig(*Manager[T]) (Configuration[T], error)
}

// NodeAddress must be implemented by types that can be used as node addresses.
type NodeAddress interface {
	Addr() string
}

type structNodeMap[K NodeID, V NodeAddress] struct {
	nodes map[K]V
}

func (structNodeMap[K, V]) isOption() {}

func (o structNodeMap[K, V]) newConfig(mgr *Manager[K]) (nodes Configuration[K], err error) {
	if len(o.nodes) == 0 {
		return nil, fmt.Errorf("config: missing required node map")
	}
	nodes = make(Configuration[K], 0, len(o.nodes))
	for id, n := range o.nodes {
		node, found := mgr.Node(id)
		if !found {
			node, err = mgr.newNode(n.Addr(), id)
			if err != nil {
				return nil, err
			}
		}
		nodes = append(nodes, node)
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy(ID[K]).Sort(mgr.nodes)
	OrderedBy(ID[K]).Sort(nodes)
	return nodes, nil
}

// WithNodes returns a NodeListOption containing the provided
// mapping from application-specific IDs to types implementing NodeAddress.
func WithNodes[K NodeID, V NodeAddress](nodes map[K]V) NodeListOption[K] {
	return &structNodeMap[K, V]{nodes: nodes}
}

type nodeIDMap struct {
	idMap map[string]uint32
}

func (nodeIDMap) isOption() {}

func (o nodeIDMap) newConfig(mgr *Manager[uint32]) (nodes Configuration[uint32], err error) {
	if len(o.idMap) == 0 {
		return nil, fmt.Errorf("config: missing required node map")
	}
	nodes = make(Configuration[uint32], 0, len(o.idMap))
	for naddr, id := range o.idMap {
		node, found := mgr.Node(id)
		if !found {
			node, err = mgr.newNode(naddr, id)
			if err != nil {
				return nil, err
			}
		}
		nodes = append(nodes, node)
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy(ID[uint32]).Sort(mgr.nodes)
	OrderedBy(ID[uint32]).Sort(nodes)
	return nodes, nil
}

// WithNodeMap returns a NodeListOption containing the provided
// mapping from node addresses to application-specific IDs.
func WithNodeMap(idMap map[string]uint32) NodeListOption[uint32] {
	return &nodeIDMap{idMap: idMap}
}

type nodeList struct {
	addrsList []string
}

func (nodeList) isOption() {}

func (o nodeList) newConfig(mgr *Manager[uint32]) (nodes Configuration[uint32], err error) {
	if len(o.addrsList) == 0 {
		return nil, fmt.Errorf("config: missing required node addresses")
	}
	nodes = make(Configuration[uint32], 0, len(o.addrsList))
	for _, naddr := range o.addrsList {
		id, err := nodeID(naddr)
		if err != nil {
			return nil, err
		}
		node, found := mgr.Node(id)
		if !found {
			node, err = mgr.newNode(naddr, id)
			if err != nil {
				return nil, err
			}
		}
		nodes = append(nodes, node)
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy(ID[uint32]).Sort(mgr.nodes)
	OrderedBy(ID[uint32]).Sort(nodes)
	return nodes, nil
}

// WithNodeList returns a NodeListOption containing the provided list of node addresses.
// With this option, node IDs are generated by the Manager (using uint32).
func WithNodeList(addrsList []string) NodeListOption[uint32] {
	return &nodeList{addrsList: addrsList}
}

type nodeIDs[T NodeID] struct {
	nodeIDs []T
}

func (nodeIDs[T]) isOption() {}

func (o nodeIDs[T]) newConfig(mgr *Manager[T]) (nodes Configuration[T], err error) {
	if len(o.nodeIDs) == 0 {
		return nil, fmt.Errorf("config: missing required node IDs")
	}
	nodes = make(Configuration[T], 0, len(o.nodeIDs))
	for _, id := range o.nodeIDs {
		node, found := mgr.Node(id)
		if !found {
			// Node IDs must have been registered previously
			return nil, fmt.Errorf("config: node %v not found", id)
		}
		nodes = append(nodes, node)
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy(ID[T]).Sort(mgr.nodes)
	OrderedBy(ID[T]).Sort(nodes)
	return nodes, nil
}

// WithNodeIDs returns a NodeListOption containing a list of node IDs.
// This assumes that the provided node IDs have already been registered with the manager.
func WithNodeIDs[T NodeID](ids []T) NodeListOption[T] {
	return &nodeIDs[T]{nodeIDs: ids}
}

type addNodes[T NodeID] struct {
	old Configuration[T]
	new NodeListOption[T]
}

func (addNodes[T]) isOption() {}

func (o addNodes[T]) newConfig(mgr *Manager[T]) (nodes Configuration[T], err error) {
	newNodes, err := o.new.newConfig(mgr)
	if err != nil {
		return nil, err
	}
	ac := &addConfig[T]{old: o.old, add: newNodes}
	return ac.newConfig(mgr)
}

// WithNewNodes returns a NodeListOption that can be used to create a new configuration
// combining c and the new nodes.
func (c Configuration[T]) WithNewNodes(newNodes NodeListOption[T]) NodeListOption[T] {
	return &addNodes[T]{old: c, new: newNodes}
}

type addConfig[T NodeID] struct {
	old Configuration[T]
	add Configuration[T]
}

func (addConfig[T]) isOption() {}

func (o addConfig[T]) newConfig(mgr *Manager[T]) (nodes Configuration[T], err error) {
	nodes = make(Configuration[T], 0, len(o.old)+len(o.add))
	m := make(map[T]bool)
	for _, n := range append(o.old, o.add...) {
		if !m[n.id] {
			m[n.id] = true
			nodes = append(nodes, n)
		}
	}
	// Sort nodes to ensure deterministic iteration.
	OrderedBy(ID[T]).Sort(mgr.nodes)
	OrderedBy(ID[T]).Sort(nodes)
	return nodes, err
}

// And returns a NodeListOption that can be used to create a new configuration combining c and d.
func (c Configuration[T]) And(d Configuration[T]) NodeListOption[T] {
	return &addConfig[T]{old: c, add: d}
}

// WithoutNodes returns a NodeListOption that can be used to create a new configuration
// from c without the given node IDs.
func (c Configuration[T]) WithoutNodes(ids ...T) NodeListOption[T] {
	rmIDs := make(map[T]bool)
	for _, id := range ids {
		rmIDs[id] = true
	}
	keepIDs := make([]T, 0, len(c))
	for _, cNode := range c {
		if !rmIDs[cNode.id] {
			keepIDs = append(keepIDs, cNode.id)
		}
	}
	return &nodeIDs[T]{nodeIDs: keepIDs}
}

// Except returns a NodeListOption that can be used to create a new configuration
// from c without the nodes in rm.
func (c Configuration[T]) Except(rm Configuration[T]) NodeListOption[T] {
	rmIDs := make(map[T]bool)
	for _, rmNode := range rm {
		rmIDs[rmNode.id] = true
	}
	keepIDs := make([]T, 0, len(c))
	for _, cNode := range c {
		if !rmIDs[cNode.id] {
			keepIDs = append(keepIDs, cNode.id)
		}
	}
	return &nodeIDs[T]{nodeIDs: keepIDs}
}

// WithoutErrors returns a NodeListOption that creates a new configuration
// excluding nodes that failed in the given QuorumCallError.
// If specific error types are provided, only nodes whose errors match
// one of those types (using errors.Is) will be excluded.
// If no error types are provided, all failed nodes are excluded.
func (c Configuration[T]) WithoutErrors(err QuorumCallError, errorTypes ...error) NodeListOption[T] {
	// Decide whether an error should exclude a node.
	exclude := func(cause error) bool {
		if len(errorTypes) == 0 {
			return true // no filter => exclude all failed nodes
		}
		for _, t := range errorTypes {
			if errors.Is(cause, t) {
				return true // match found
			}
		}
		return false
	}

	// Build a map of node IDs to exclude
	rm := make(map[T]bool, len(err.errors))
	for _, ne := range err.errors {
		rm[ne.nodeID.(T)] = exclude(ne.cause)
	}

	// Build the list of node IDs to keep
	keepIDs := make([]T, 0, len(c))
	for _, node := range c {
		if !rm[node.id] {
			keepIDs = append(keepIDs, node.id)
		}
	}
	return &nodeIDs[T]{nodeIDs: keepIDs}
}
