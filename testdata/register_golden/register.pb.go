// Code generated by protoc-gen-gogo.
// source: testdata/register_golden/register.proto
// DO NOT EDIT!

/*
	Package dev is a generated protocol buffer package.

	Package dev provides a blueprint for testing the various call semantics provided by Gorums.
	The following table explains the differences in how the different call semantics work.

	                   Replies per server      Gorums termination check    # times qfunc can update result     Server-side reply type
	------------------------------------------------------------------------------------------------------------------------------------------------
	Quorum call                 1                   Reply + error count                 1                           Single response
	Correctable QC              1                   Reply + error count                 N                           Single response
	Correctable QC w/prelim     M                   Error count                         M                           Stream of responses

	It is generated from these files:
		testdata/register_golden/register.proto

	It has these top-level messages:
		State
		MyState
		WriteResponse
		ReadRequest
		Empty
*/
package dev

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/relab/gorums"

import (
	"bytes"
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"

	"golang.org/x/net/trace"

	"google.golang.org/grpc/codes"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type State struct {
	Value     string `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int64  `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptorRegister, []int{0} }

type MyState struct {
	Value     string `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Timestamp int64  `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Extra     int64  `protobuf:"varint,3,opt,name=Extra,proto3" json:"Extra,omitempty"`
}

func (m *MyState) Reset()                    { *m = MyState{} }
func (*MyState) ProtoMessage()               {}
func (*MyState) Descriptor() ([]byte, []int) { return fileDescriptorRegister, []int{1} }

type WriteResponse struct {
	New bool `protobuf:"varint,1,opt,name=New,proto3" json:"New,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorRegister, []int{2} }

type ReadRequest struct {
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorRegister, []int{3} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorRegister, []int{4} }

func init() {
	proto.RegisterType((*State)(nil), "dev.State")
	proto.RegisterType((*MyState)(nil), "dev.MyState")
	proto.RegisterType((*WriteResponse)(nil), "dev.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "dev.ReadRequest")
	proto.RegisterType((*Empty)(nil), "dev.Empty")
}
func (this *State) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*State)
	if !ok {
		that2, ok := that.(State)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *State")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *State but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *State but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	return nil
}
func (this *State) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*State)
	if !ok {
		that2, ok := that.(State)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	return true
}
func (this *MyState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MyState)
	if !ok {
		that2, ok := that.(MyState)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MyState")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MyState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MyState but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Extra != that1.Extra {
		return fmt.Errorf("Extra this(%v) Not Equal that(%v)", this.Extra, that1.Extra)
	}
	return nil
}
func (this *MyState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MyState)
	if !ok {
		that2, ok := that.(MyState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Extra != that1.Extra {
		return false
	}
	return true
}
func (this *WriteResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *WriteResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WriteResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WriteResponse but is not nil && this == nil")
	}
	if this.New != that1.New {
		return fmt.Errorf("New this(%v) Not Equal that(%v)", this.New, that1.New)
	}
	return nil
}
func (this *WriteResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.New != that1.New {
		return false
	}
	return true
}
func (this *ReadRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ReadRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReadRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReadRequest but is not nil && this == nil")
	}
	return nil
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *Empty) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Empty")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Empty but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Empty but is not nil && this == nil")
	}
	return nil
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}

//  Reference Gorums specific imports to suppress errors if they are not otherwise used.
var _ = codes.OK

/* 'gorums' plugin for protoc-gen-go - generated from: calltype_correctable_prelim_tmpl */

/* Methods on Configuration and the correctable prelim struct ReadPrelimReply */

// ReadPrelimReply is a reference to a correctable quorum call
// with server side preliminary reply support.
type ReadPrelimReply struct {
	sync.Mutex
	// the actual reply
	*State
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// ReadPrelim asynchronously invokes a correctable ReadPrelim quorum call
// with server side preliminary reply support on configuration c and returns a
// ReadPrelimReply which can be used to inspect any replies or errors
// when available.
func (c *Configuration) ReadPrelim(ctx context.Context, args *ReadRequest) *ReadPrelimReply {
	corr := &ReadPrelimReply{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go func() {
		c.mgr.readPrelim(ctx, c, corr, args)
	}()
	return corr
}

// Get returns the reply, level and any error associated with the
// ReadPrelim. The method does not block until a (possibly
// itermidiate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *ReadPrelimReply) Get() (*State, int, error) {
	c.Lock()
	defer c.Unlock()
	return c.State, c.level, c.err
}

// Done returns a channel that's closed when the correctable ReadPrelim
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or that the call returned an
// error.
func (c *ReadPrelimReply) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that's closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// disregardless of the specified level.
func (c *ReadPrelimReply) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.Lock()
	if level < c.level {
		close(ch)
		c.Unlock()
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	c.Unlock()
	return ch
}

func (c *ReadPrelimReply) set(reply *State, level int, err error, done bool) {
	c.Lock()
	if c.done {
		c.Unlock()
		panic("set(...) called on a done correctable")
	}
	c.State, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		c.Unlock()
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
	c.Unlock()
}

/* Methods on Manager for correctable prelim method ReadPrelim */

type readPrelimReply struct {
	nid   uint32
	reply *State
	err   error
}

func (m *Manager) readPrelim(ctx context.Context, c *Configuration, corr *ReadPrelimReply, args *ReadRequest) {
	replyChan := make(chan readPrelimReply, c.n)

	for _, n := range c.nodes {
		go callGRPCReadPrelimStream(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*State, 0, c.n*2)
		clevel      = LevelNotSet
		reply       *State
		rlevel      int
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			corr.NodeIDs = appendIfNotPresent(corr.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			replyValues = append(replyValues, r.reply)
			reply, rlevel, quorum = c.qspec.ReadPrelimQF(replyValues)
			if quorum {
				corr.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				corr.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			corr.set(reply, clevel, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}, true)
			return
		}

		if errCount == c.n { // Can't rely on reply count.
			corr.set(reply, clevel, QuorumCallError{"incomplete call", errCount, len(replyValues)}, true)
			return
		}
	}
}

func callGRPCReadPrelimStream(ctx context.Context, node *Node, args *ReadRequest, replyChan chan<- readPrelimReply) {
	x := NewRegisterClient(node.conn)
	y, err := x.ReadPrelim(ctx, args)
	if err != nil {
		replyChan <- readPrelimReply{node.id, nil, err}
		return
	}

	for {
		reply, err := y.Recv()
		if err == io.EOF {
			return
		}
		replyChan <- readPrelimReply{node.id, reply, err}
		if err != nil {
			return
		}
	}
}

/* 'gorums' plugin for protoc-gen-go - generated from: calltype_correctable_tmpl */

/* Methods on Configuration and the correctable struct ReadCorrectableReply */

// ReadCorrectableReply is a reference to a correctable ReadCorrectable quorum call.
type ReadCorrectableReply struct {
	sync.Mutex
	// the actual reply
	*State
	NodeIDs  []uint32
	level    int
	err      error
	done     bool
	watchers []*struct {
		level int
		ch    chan struct{}
	}
	donech chan struct{}
}

// ReadCorrectable asynchronously invokes a
// correctable ReadCorrectable quorum call on configuration c and returns a
// ReadCorrectableReply which can be used to inspect any replies or errors
// when available.
func (c *Configuration) ReadCorrectable(ctx context.Context, args *ReadRequest) *ReadCorrectableReply {
	corr := &ReadCorrectableReply{
		level:   LevelNotSet,
		NodeIDs: make([]uint32, 0, c.n),
		donech:  make(chan struct{}),
	}
	go func() {
		c.mgr.readCorrectable(ctx, c, corr, args)
	}()
	return corr
}

// Get returns the reply, level and any error associated with the
// ReadCorrectable. The method does not block until a (possibly
// itermidiate) reply or error is available. Level is set to LevelNotSet if no
// reply has yet been received. The Done or Watch methods should be used to
// ensure that a reply is available.
func (c *ReadCorrectableReply) Get() (*State, int, error) {
	c.Lock()
	defer c.Unlock()
	return c.State, c.level, c.err
}

// Done returns a channel that's closed when the correctable ReadCorrectable
// quorum call is done. A call is considered done when the quorum function has
// signaled that a quorum of replies was received or that the call returned an
// error.
func (c *ReadCorrectableReply) Done() <-chan struct{} {
	return c.donech
}

// Watch returns a channel that's closed when a reply or error at or above the
// specified level is available. If the call is done, the channel is closed
// disregardless of the specified level.
func (c *ReadCorrectableReply) Watch(level int) <-chan struct{} {
	ch := make(chan struct{})
	c.Lock()
	if level < c.level {
		close(ch)
		c.Unlock()
		return ch
	}
	c.watchers = append(c.watchers, &struct {
		level int
		ch    chan struct{}
	}{level, ch})
	c.Unlock()
	return ch
}

func (c *ReadCorrectableReply) set(reply *State, level int, err error, done bool) {
	c.Lock()
	if c.done {
		c.Unlock()
		panic("set(...) called on a done correctable")
	}
	c.State, c.level, c.err, c.done = reply, level, err, done
	if done {
		close(c.donech)
		for _, watcher := range c.watchers {
			if watcher != nil {
				close(watcher.ch)
			}
		}
		c.Unlock()
		return
	}
	for i := range c.watchers {
		if c.watchers[i] != nil && c.watchers[i].level <= level {
			close(c.watchers[i].ch)
			c.watchers[i] = nil
		}
	}
	c.Unlock()
}

/* Methods on Manager for correctable method ReadCorrectable */

type readCorrectableReply struct {
	nid   uint32
	reply *State
	err   error
}

func (m *Manager) readCorrectable(ctx context.Context, c *Configuration, corr *ReadCorrectableReply, args *ReadRequest) {
	replyChan := make(chan readCorrectableReply, c.n)

	for _, n := range c.nodes {
		go callGRPCReadCorrectable(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*State, 0, c.n)
		clevel      = LevelNotSet
		reply       *State
		rlevel      int
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			corr.NodeIDs = append(corr.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			replyValues = append(replyValues, r.reply)
			reply, rlevel, quorum = c.qspec.ReadCorrectableQF(replyValues)
			if quorum {
				corr.set(reply, rlevel, nil, true)
				return
			}
			if rlevel > clevel {
				clevel = rlevel
				corr.set(reply, rlevel, nil, false)
			}
		case <-ctx.Done():
			corr.set(reply, clevel, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}, true)
			return
		}

		if errCount+len(replyValues) == c.n {
			corr.set(reply, clevel, QuorumCallError{"incomplete call", errCount, len(replyValues)}, true)
			return
		}
	}
}

func callGRPCReadCorrectable(ctx context.Context, node *Node, arg *ReadRequest, replyChan chan<- readCorrectableReply) {
	reply := new(State)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/ReadCorrectable",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- readCorrectableReply{node.id, reply, err}
}

/* 'gorums' plugin for protoc-gen-go - generated from: calltype_future_tmpl */

/* Methods on Configuration and the future type struct ReadFutureReply */

// ReadFutureReply is a future object for an asynchronous ReadFuture quorum call invocation.
type ReadFutureReply struct {
	// the actual reply
	*State
	NodeIDs []uint32
	err     error
	c       chan struct{}
}

// ReadFuture asynchronously invokes a ReadFuture quorum call
// on configuration c and returns a ReadFutureReply which can be used to
// inspect the quorum call reply and error when available.
func (c *Configuration) ReadFuture(ctx context.Context, arg *ReadRequest) *ReadFutureReply {
	f := &ReadFutureReply{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(f.c)
		c.readFuture(ctx, arg, f)
	}()
	return f
}

// Get returns the reply and any error associated with the ReadFuture.
// The method blocks until a reply or error is available.
func (f *ReadFutureReply) Get() (*State, error) {
	<-f.c
	return f.State, f.err
}

// Done reports if a reply and/or error is available for the ReadFuture.
func (f *ReadFutureReply) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

/* Unexported types and methods for asynchronous method ReadFuture */

type readFutureReply struct {
	nid   uint32
	reply *State
	err   error
}

func (c *Configuration) readFuture(ctx context.Context, a *ReadRequest, resp *ReadFutureReply) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "ReadFuture")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.State,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan readFutureReply, c.n)
	for _, n := range c.nodes {
		go callGRPCReadFuture(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*State, 0, c.n)
		reply       *State
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply, quorum = c.qspec.ReadFutureQF(replyValues); quorum {
				resp.State, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.State, resp.err = reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
			return
		}

		if errCount+len(replyValues) == c.n {
			resp.State, resp.err = reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
			return
		}
	}
}

func callGRPCReadFuture(ctx context.Context, node *Node, arg *ReadRequest, replyChan chan<- readFutureReply) {
	reply := new(State)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/ReadFuture",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- readFutureReply{node.id, reply, err}
}

/* Methods on Configuration and the future type struct WriteFutureReply */

// WriteFutureReply is a future object for an asynchronous WriteFuture quorum call invocation.
type WriteFutureReply struct {
	// the actual reply
	*WriteResponse
	NodeIDs []uint32
	err     error
	c       chan struct{}
}

// WriteFuture asynchronously invokes a WriteFuture quorum call
// on configuration c and returns a WriteFutureReply which can be used to
// inspect the quorum call reply and error when available.
func (c *Configuration) WriteFuture(ctx context.Context, arg *State) *WriteFutureReply {
	f := &WriteFutureReply{
		NodeIDs: make([]uint32, 0, c.n),
		c:       make(chan struct{}, 1),
	}
	go func() {
		defer close(f.c)
		c.writeFuture(ctx, arg, f)
	}()
	return f
}

// Get returns the reply and any error associated with the WriteFuture.
// The method blocks until a reply or error is available.
func (f *WriteFutureReply) Get() (*WriteResponse, error) {
	<-f.c
	return f.WriteResponse, f.err
}

// Done reports if a reply and/or error is available for the WriteFuture.
func (f *WriteFutureReply) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

/* Unexported types and methods for asynchronous method WriteFuture */

type writeFutureReply struct {
	nid   uint32
	reply *WriteResponse
	err   error
}

func (c *Configuration) writeFuture(ctx context.Context, a *State, resp *WriteFutureReply) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "WriteFuture")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.WriteResponse,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan writeFutureReply, c.n)
	for _, n := range c.nodes {
		go callGRPCWriteFuture(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*WriteResponse, 0, c.n)
		reply       *WriteResponse
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if reply, quorum = c.qspec.WriteFutureQF(a, replyValues); quorum {
				resp.WriteResponse, resp.err = reply, nil
				return
			}
		case <-ctx.Done():
			resp.WriteResponse, resp.err = reply, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
			return
		}

		if errCount+len(replyValues) == c.n {
			resp.WriteResponse, resp.err = reply, QuorumCallError{"incomplete call", errCount, len(replyValues)}
			return
		}
	}
}

func callGRPCWriteFuture(ctx context.Context, node *Node, arg *State, replyChan chan<- writeFutureReply) {
	reply := new(WriteResponse)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/WriteFuture",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- writeFutureReply{node.id, reply, err}
}

/* 'gorums' plugin for protoc-gen-go - generated from: calltype_multicast_tmpl */

// WriteAsync is a one-way multicast call on all nodes in configuration c,
// using the same argument arg. The call is asynchronous and has no return value.
func (c *Configuration) WriteAsync(ctx context.Context, arg *State) error {
	return c.writeAsync(ctx, arg)
}

func (c *Configuration) writeAsync(ctx context.Context, arg *State) error {
	for _, node := range c.nodes {
		go func(n *Node) {
			err := n.WriteAsyncClient.Send(arg)
			if err == nil {
				return
			}
			if c.mgr.logger != nil {
				c.mgr.logger.Printf("%d: writeAsync stream send error: %v", n.id, err)
			}
		}(node)
	}

	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: calltype_quorumcall_tmpl */

/* Methods on Configuration and the quorum call struct Read */

//TODO Make this a customizable struct that replaces FQRespName together with typedecl option in gogoprotobuf.
//(This file could maybe hold all types of structs for the different call semantics)

// ReadReply encapsulates the reply from a Read quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type ReadReply struct {
	// the actual reply
	*State
	NodeIDs []uint32
	err     error
}

func (r ReadReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.State)
}

// Read is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result as a ReadReply.
func (c *Configuration) Read(ctx context.Context, arg *ReadRequest) (*ReadReply, error) {
	return c.read(ctx, arg)
}

/* Methods on Manager for quorum call method Read */

type readReply struct {
	nid   uint32
	reply *State
	err   error
}

func (c *Configuration) read(ctx context.Context, a *ReadRequest) (resp *ReadReply, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "Read")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.State,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan readReply, c.n)
	for _, n := range c.nodes {
		go callGRPCRead(ctx, n, a, replyChan)
	}

	resp = &ReadReply{NodeIDs: make([]uint32, 0, c.n)}
	var (
		replyValues = make([]*State, 0, c.n)
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp.State, quorum = c.qspec.ReadQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return resp, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCRead(ctx context.Context, node *Node, arg *ReadRequest, replyChan chan<- readReply) {
	reply := new(State)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/Read",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- readReply{node.id, reply, err}
}

/* Methods on Configuration and the quorum call struct ReadCustomReturn */

//TODO Make this a customizable struct that replaces FQRespName together with typedecl option in gogoprotobuf.
//(This file could maybe hold all types of structs for the different call semantics)

// ReadCustomReturnReply encapsulates the reply from a ReadCustomReturn quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type ReadCustomReturnReply struct {
	// the actual reply
	*MyState
	NodeIDs []uint32
	err     error
}

func (r ReadCustomReturnReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.MyState)
}

// ReadCustomReturn is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result as a ReadCustomReturnReply.
func (c *Configuration) ReadCustomReturn(ctx context.Context, arg *ReadRequest) (*ReadCustomReturnReply, error) {
	return c.readCustomReturn(ctx, arg)
}

/* Methods on Manager for quorum call method ReadCustomReturn */

type readCustomReturnReply struct {
	nid   uint32
	reply *State
	err   error
}

func (c *Configuration) readCustomReturn(ctx context.Context, a *ReadRequest) (resp *ReadCustomReturnReply, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "ReadCustomReturn")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.MyState,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan readCustomReturnReply, c.n)
	for _, n := range c.nodes {
		go callGRPCReadCustomReturn(ctx, n, a, replyChan)
	}

	resp = &ReadCustomReturnReply{NodeIDs: make([]uint32, 0, c.n)}
	var (
		replyValues = make([]*State, 0, c.n)
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp.MyState, quorum = c.qspec.ReadCustomReturnQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return resp, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCReadCustomReturn(ctx context.Context, node *Node, arg *ReadRequest, replyChan chan<- readCustomReturnReply) {
	reply := new(State)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/ReadCustomReturn",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- readCustomReturnReply{node.id, reply, err}
}

/* Methods on Configuration and the quorum call struct Write */

//TODO Make this a customizable struct that replaces FQRespName together with typedecl option in gogoprotobuf.
//(This file could maybe hold all types of structs for the different call semantics)

// WriteReply encapsulates the reply from a Write quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type WriteReply struct {
	// the actual reply
	*WriteResponse
	NodeIDs []uint32
	err     error
}

func (r WriteReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.WriteResponse)
}

// Write is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result as a WriteReply.
func (c *Configuration) Write(ctx context.Context, arg *State) (*WriteReply, error) {
	return c.write(ctx, arg)
}

/* Methods on Manager for quorum call method Write */

type writeReply struct {
	nid   uint32
	reply *WriteResponse
	err   error
}

func (c *Configuration) write(ctx context.Context, a *State) (resp *WriteReply, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "Write")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.WriteResponse,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan writeReply, c.n)
	for _, n := range c.nodes {
		go callGRPCWrite(ctx, n, a, replyChan)
	}

	resp = &WriteReply{NodeIDs: make([]uint32, 0, c.n)}
	var (
		replyValues = make([]*WriteResponse, 0, c.n)
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp.WriteResponse, quorum = c.qspec.WriteQF(a, replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return resp, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCWrite(ctx context.Context, node *Node, arg *State, replyChan chan<- writeReply) {
	reply := new(WriteResponse)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/Write",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- writeReply{node.id, reply, err}
}

/* Methods on Configuration and the quorum call struct WritePerNode */

//TODO Make this a customizable struct that replaces FQRespName together with typedecl option in gogoprotobuf.
//(This file could maybe hold all types of structs for the different call semantics)

// WritePerNodeReply encapsulates the reply from a WritePerNode quorum call.
// It contains the id of each node of the quorum that replied and a single reply.
type WritePerNodeReply struct {
	// the actual reply
	*WriteResponse
	NodeIDs []uint32
	err     error
}

func (r WritePerNodeReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.WriteResponse)
}

// WritePerNode is invoked as a quorum call on each node in configuration c,
// with the argument returned by the provided perNode function and returns the
// result as a WritePerNodeReply. The perNode function returns a *State
// object to be passed to the given nodeID.
func (c *Configuration) WritePerNode(ctx context.Context, arg *State, perNode func(arg State, nodeID uint32) *State) (*WritePerNodeReply, error) {
	return c.writePerNode(ctx, arg, perNode)
}

/* Methods on Manager for quorum call method WritePerNode */

type writePerNodeReply struct {
	nid   uint32
	reply *WriteResponse
	err   error
}

func (c *Configuration) writePerNode(ctx context.Context, a *State, f func(arg State, nodeID uint32) *State) (resp *WritePerNodeReply, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.tr = trace.New("gorums."+c.tstring()+".Sent", "WritePerNode")
		defer ti.tr.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.tr.LazyLog(&ti.firstLine, false)
		ti.tr.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.tr.LazyLog(&qcresult{
				ids:   resp.NodeIDs,
				reply: resp.WriteResponse,
				err:   resp.err,
			}, false)
			if resp.err != nil {
				ti.tr.SetError()
			}
		}()
	}

	replyChan := make(chan writePerNodeReply, c.n)
	for _, n := range c.nodes {
		go callGRPCWritePerNode(ctx, n, f(*a, n.id), replyChan)
	}

	resp = &WritePerNodeReply{NodeIDs: make([]uint32, 0, c.n)}
	var (
		replyValues = make([]*WriteResponse, 0, c.n)
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			resp.NodeIDs = append(resp.NodeIDs, r.nid)
			if r.err != nil {
				errCount++
				break
			}
			if c.mgr.opts.trace {
				ti.tr.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp.WriteResponse, quorum = c.qspec.WritePerNodeQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), errCount, len(replyValues)}
		}

		if errCount+len(replyValues) == c.n {
			return resp, QuorumCallError{"incomplete call", errCount, len(replyValues)}
		}
	}
}

func callGRPCWritePerNode(ctx context.Context, node *Node, arg *State, replyChan chan<- writePerNodeReply) {
	reply := new(WriteResponse)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/dev.Register/WritePerNode",
		arg,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- writePerNodeReply{node.id, reply, err}
}

/* 'gorums' plugin for protoc-gen-go - generated from: node_tmpl */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id   uint32
	self bool
	addr string
	conn *grpc.ClientConn

	RegisterClient RegisterClient

	WriteAsyncClient Register_WriteAsyncClient

	sync.Mutex
	lastErr error
	latency time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	var err error
	n.conn, err = grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}

	n.RegisterClient = NewRegisterClient(n.conn)

	n.WriteAsyncClient, err = n.RegisterClient.WriteAsync(context.Background())
	if err != nil {
		return fmt.Errorf("stream creation failed: %v", err)
	}

	return nil
}

func (n *Node) close() error {
	// TODO: Log error, mainly care about the connection error below.
	// We should log this error, but we currently don't have access to the
	// logger in the manager.
	_, _ = n.WriteAsyncClient.CloseAndRecv()

	if err := n.conn.Close(); err != nil {
		return fmt.Errorf("conn close error: %v", err)
	}
	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: qspec_tmpl */

// QuorumSpec is the interface that wraps every quorum function.
type QuorumSpec interface {
	// ReadQF is the quorum function for the Read
	// quorum call method.
	ReadQF(replies []*State) (*State, bool)

	// ReadCorrectableQF is the quorum function for the ReadCorrectable
	// correctable quorum call method.
	ReadCorrectableQF(replies []*State) (*State, int, bool)

	// ReadCustomReturnQF is the quorum function for the ReadCustomReturn
	// quorum call method.
	ReadCustomReturnQF(replies []*State) (*MyState, bool)

	// ReadFutureQF is the quorum function for the ReadFuture
	// quorum call method.
	ReadFutureQF(replies []*State) (*State, bool)

	// ReadPrelimCorrectablePrelimQF is the quorum function for the ReadPrelim
	// correctable prelim quourm call method.
	ReadPrelimQF(replies []*State) (*State, int, bool)

	// WriteQF is the quorum function for the Write
	// quorum call method.
	WriteQF(req *State, replies []*WriteResponse) (*WriteResponse, bool)

	// WriteFutureQF is the quorum function for the WriteFuture
	// quorum call method.
	WriteFutureQF(req *State, replies []*WriteResponse) (*WriteResponse, bool)

	// WritePerNodeQF is the quorum function for the WritePerNode
	// quorum call method.
	WritePerNodeQF(replies []*WriteResponse) (*WriteResponse, bool)
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id    uint32
	nodes []*Node
	n     int
	mgr   *Manager
	qspec QuorumSpec
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration. IDs are returned in the same order as they were provided in
// the creation of the Configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Configuration.
func (c *Configuration) Nodes() []*Node {
	return c.nodes
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d", c.id)
}

func (c *Configuration) tstring() string {
	return fmt.Sprintf("config-%d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// NewTestConfiguration returns a new configuration with quorum size q and
// node size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		nodes: make([]*Node, n),
	}
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

// A QuorumCallError is used to report that a quorum call failed.
type QuorumCallError struct {
	Reason               string
	ErrCount, ReplyCount int
}

func (e QuorumCallError) Error() string {
	return fmt.Sprintf(
		"quorum call error: %s (errors: %d, replies: %d)",
		e.Reason, e.ErrCount, e.ReplyCount,
	)
}

/* level.go */

// LevelNotSet is the zero value level used to indicate that no level (and
// thereby no reply) has been set for a correctable quorum call.
const LevelNotSet = -1

/* mgr.go */

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.Mutex
	nodes    []*Node
	lookup   map[uint32]*Node
	configs  map[uint32]*Configuration
	eventLog trace.EventLog

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := &Manager{
		lookup:  make(map[uint32]*Node),
		configs: make(map[uint32]*Configuration),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	for _, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err2)
		}
		m.lookup[node.id] = node
		m.nodes = append(m.nodes, node)
	}

	if m.opts.trace {
		title := strings.Join(nodeAddrs, ",")
		m.eventLog = trace.NewEventLog("gorums.Manager", title)
	}

	err := m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	if m.eventLog != nil {
		m.eventLog.Printf("ready")
	}

	return m, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	id := h.Sum32()

	if _, found := m.lookup[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}

	if m.eventLog != nil {
		m.eventLog.Printf("connecting")
	}

	for _, node := range m.nodes {
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			if m.eventLog != nil {
				m.eventLog.Errorf("connect failed, error connecting to node %s, error: %v", node.addr, err)
			}
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		if m.eventLog != nil {
			m.eventLog.Printf("closing")
		}
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node. IDs are returned in
// the same order as they were provided in the creation of the Manager.
func (m *Manager) NodeIDs() []uint32 {
	m.Lock()
	defer m.Unlock()
	ids := make([]uint32, 0, len(m.nodes))
	for _, node := range m.nodes {
		ids = append(ids, node.ID())
	}
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.Lock()
	defer m.Unlock()
	node, found = m.lookup[id]
	return node, found
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Manager.
func (m *Manager) Nodes() []*Node {
	m.Lock()
	defer m.Unlock()
	return m.nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.Lock()
	defer m.Unlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.Lock()
	defer m.Unlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.Lock()
	defer m.Unlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.Lock()
	defer m.Unlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}

	var cnodes []*Node
	for _, nid := range ids {
		node, found := m.lookup[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted ensure a globally consistent configuration id.
	sort.Sort(idSlice(ids))

	h := fnv.New32a()
	for _, id := range ids {
		binary.Write(h, binary.LittleEndian, id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:    cid,
		nodes: cnodes,
		n:     len(cnodes),
		mgr:   m,
		qspec: qspec,
	}
	m.configs[cid] = c

	return c, nil
}

type idSlice []uint32

func (p idSlice) Len() int           { return len(p) }
func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p idSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

/* node_func.go */

// ID returns the ID of m.
func (n *Node) ID() uint32 {
	return n.id
}

// Address returns network address of m.
func (n *Node) Address() string {
	return n.addr
}

func (n *Node) String() string {
	n.Lock()
	defer n.Unlock()
	return fmt.Sprintf(
		"node %d | addr: %s | latency: %v",
		n.id, n.addr, n.latency,
	)
}

func (n *Node) setLastErr(err error) {
	n.Lock()
	defer n.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.Lock()
	defer n.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.Lock()
	defer n.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.Lock()
	defer n.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

/* opts.go */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	trace        bool
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithTracing controls whether to trace qourum calls for this Manager instance
// using the golang.org/x/net/trace package. Tracing is currently only supported
// for regular quorum calls.
func WithTracing() ManagerOption {
	return func(o *managerOptions) {
		o.trace = true
	}
}

/* trace.go */

type traceInfo struct {
	tr        trace.Trace
	firstLine firstLine
}

type firstLine struct {
	deadline time.Duration
	cid      uint32
}

func (f *firstLine) String() string {
	var line bytes.Buffer
	io.WriteString(&line, "QC: to config")
	fmt.Fprintf(&line, "%v deadline:", f.cid)
	if f.deadline != 0 {
		fmt.Fprint(&line, f.deadline)
	} else {
		io.WriteString(&line, "none")
	}
	return line.String()
}

type payload struct {
	sent bool
	id   uint32
	msg  interface{}
}

func (p payload) String() string {
	if p.sent {
		return fmt.Sprintf("sent: %v", p.msg)
	}
	return fmt.Sprintf("recv from %d: %v", p.id, p.msg)
}

type qcresult struct {
	ids   []uint32
	reply interface{}
	err   error
}

func (q qcresult) String() string {
	var out bytes.Buffer
	io.WriteString(&out, "recv QC reply: ")
	fmt.Fprintf(&out, "ids: %v, ", q.ids)
	fmt.Fprintf(&out, "reply: %v ", q.reply)
	if q.err != nil {
		fmt.Fprintf(&out, ", error: %v", q.err)
	}
	return out.String()
}

/* util.go */

func appendIfNotPresent(set []uint32, x uint32) []uint32 {
	for _, y := range set {
		if y == x {
			return set
		}
	}
	return append(set, x)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Register service

type RegisterClient interface {
	// ReadNoQC is a plain gRPC call.
	ReadNoQC(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error)
	// Read is a synchronous quorum call.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error)
	// ReadFuture is an asynchronous quorum call that
	// returns a future object for retrieving results.
	ReadFuture(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error)
	// ReadCustomReturn is a synchronous quorum call with a custom return type
	ReadCustomReturn(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error)
	// ReadCorrectable is an asynchronous correctable quorum call that
	// returns a correctable object for retrieving results.
	// TODO update DOC (useful for EPaxos)
	ReadCorrectable(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error)
	// ReadPrelim is an asynchronous correctable quorum call that
	// returns a correctable object for retrieving results.
	// TODO update DOC
	ReadPrelim(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Register_ReadPrelimClient, error)
	// Write is a synchronous quorum call.
	// The request argument (State) is passed to the associated
	// quorum function, WriteQF, for this method.
	Write(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error)
	// WriteFuture is an asynchronous quorum call that
	// returns a future object for retrieving results.
	// The request argument (State) is passed to the associated
	// quorum function, WriteFutureQF, for this method.
	WriteFuture(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error)
	// WriteAsync is an asynchronous multicast to all nodes in a configuration.
	// No replies are collected.
	WriteAsync(ctx context.Context, opts ...grpc.CallOption) (Register_WriteAsyncClient, error)
	// WritePerNode is a synchronous quorum call, where,
	// for each node, a provided function is called to determine
	// the argument to be sent to that node.
	WritePerNode(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error)
}

type registerClient struct {
	cc *grpc.ClientConn
}

func NewRegisterClient(cc *grpc.ClientConn) RegisterClient {
	return &registerClient{cc}
}

func (c *registerClient) ReadNoQC(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/dev.Register/ReadNoQC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/dev.Register/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) ReadFuture(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/dev.Register/ReadFuture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) ReadCustomReturn(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/dev.Register/ReadCustomReturn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) ReadCorrectable(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/dev.Register/ReadCorrectable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) ReadPrelim(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Register_ReadPrelimClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Register_serviceDesc.Streams[0], c.cc, "/dev.Register/ReadPrelim", opts...)
	if err != nil {
		return nil, err
	}
	x := &registerReadPrelimClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Register_ReadPrelimClient interface {
	Recv() (*State, error)
	grpc.ClientStream
}

type registerReadPrelimClient struct {
	grpc.ClientStream
}

func (x *registerReadPrelimClient) Recv() (*State, error) {
	m := new(State)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *registerClient) Write(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/dev.Register/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) WriteFuture(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/dev.Register/WriteFuture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registerClient) WriteAsync(ctx context.Context, opts ...grpc.CallOption) (Register_WriteAsyncClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Register_serviceDesc.Streams[1], c.cc, "/dev.Register/WriteAsync", opts...)
	if err != nil {
		return nil, err
	}
	x := &registerWriteAsyncClient{stream}
	return x, nil
}

type Register_WriteAsyncClient interface {
	Send(*State) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type registerWriteAsyncClient struct {
	grpc.ClientStream
}

func (x *registerWriteAsyncClient) Send(m *State) error {
	return x.ClientStream.SendMsg(m)
}

func (x *registerWriteAsyncClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *registerClient) WritePerNode(ctx context.Context, in *State, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/dev.Register/WritePerNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Register service

type RegisterServer interface {
	// ReadNoQC is a plain gRPC call.
	ReadNoQC(context.Context, *ReadRequest) (*State, error)
	// Read is a synchronous quorum call.
	Read(context.Context, *ReadRequest) (*State, error)
	// ReadFuture is an asynchronous quorum call that
	// returns a future object for retrieving results.
	ReadFuture(context.Context, *ReadRequest) (*State, error)
	// ReadCustomReturn is a synchronous quorum call with a custom return type
	ReadCustomReturn(context.Context, *ReadRequest) (*State, error)
	// ReadCorrectable is an asynchronous correctable quorum call that
	// returns a correctable object for retrieving results.
	// TODO update DOC (useful for EPaxos)
	ReadCorrectable(context.Context, *ReadRequest) (*State, error)
	// ReadPrelim is an asynchronous correctable quorum call that
	// returns a correctable object for retrieving results.
	// TODO update DOC
	ReadPrelim(*ReadRequest, Register_ReadPrelimServer) error
	// Write is a synchronous quorum call.
	// The request argument (State) is passed to the associated
	// quorum function, WriteQF, for this method.
	Write(context.Context, *State) (*WriteResponse, error)
	// WriteFuture is an asynchronous quorum call that
	// returns a future object for retrieving results.
	// The request argument (State) is passed to the associated
	// quorum function, WriteFutureQF, for this method.
	WriteFuture(context.Context, *State) (*WriteResponse, error)
	// WriteAsync is an asynchronous multicast to all nodes in a configuration.
	// No replies are collected.
	WriteAsync(Register_WriteAsyncServer) error
	// WritePerNode is a synchronous quorum call, where,
	// for each node, a provided function is called to determine
	// the argument to be sent to that node.
	WritePerNode(context.Context, *State) (*WriteResponse, error)
}

func RegisterRegisterServer(s *grpc.Server, srv RegisterServer) {
	s.RegisterService(&_Register_serviceDesc, srv)
}

func _Register_ReadNoQC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).ReadNoQC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/ReadNoQC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).ReadNoQC(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_ReadFuture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).ReadFuture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/ReadFuture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).ReadFuture(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_ReadCustomReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).ReadCustomReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/ReadCustomReturn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).ReadCustomReturn(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_ReadCorrectable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).ReadCorrectable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/ReadCorrectable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).ReadCorrectable(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_ReadPrelim_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RegisterServer).ReadPrelim(m, &registerReadPrelimServer{stream})
}

type Register_ReadPrelimServer interface {
	Send(*State) error
	grpc.ServerStream
}

type registerReadPrelimServer struct {
	grpc.ServerStream
}

func (x *registerReadPrelimServer) Send(m *State) error {
	return x.ServerStream.SendMsg(m)
}

func _Register_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(State)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).Write(ctx, req.(*State))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_WriteFuture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(State)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).WriteFuture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/WriteFuture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).WriteFuture(ctx, req.(*State))
	}
	return interceptor(ctx, in, info, handler)
}

func _Register_WriteAsync_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RegisterServer).WriteAsync(&registerWriteAsyncServer{stream})
}

type Register_WriteAsyncServer interface {
	SendAndClose(*Empty) error
	Recv() (*State, error)
	grpc.ServerStream
}

type registerWriteAsyncServer struct {
	grpc.ServerStream
}

func (x *registerWriteAsyncServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *registerWriteAsyncServer) Recv() (*State, error) {
	m := new(State)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Register_WritePerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(State)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegisterServer).WritePerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.Register/WritePerNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegisterServer).WritePerNode(ctx, req.(*State))
	}
	return interceptor(ctx, in, info, handler)
}

var _Register_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dev.Register",
	HandlerType: (*RegisterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadNoQC",
			Handler:    _Register_ReadNoQC_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Register_Read_Handler,
		},
		{
			MethodName: "ReadFuture",
			Handler:    _Register_ReadFuture_Handler,
		},
		{
			MethodName: "ReadCustomReturn",
			Handler:    _Register_ReadCustomReturn_Handler,
		},
		{
			MethodName: "ReadCorrectable",
			Handler:    _Register_ReadCorrectable_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _Register_Write_Handler,
		},
		{
			MethodName: "WriteFuture",
			Handler:    _Register_WriteFuture_Handler,
		},
		{
			MethodName: "WritePerNode",
			Handler:    _Register_WritePerNode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadPrelim",
			Handler:       _Register_ReadPrelim_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteAsync",
			Handler:       _Register_WriteAsync_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "testdata/register_golden/register.proto",
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRegister(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegister(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *MyState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MyState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRegister(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRegister(dAtA, i, uint64(m.Timestamp))
	}
	if m.Extra != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRegister(dAtA, i, uint64(m.Extra))
	}
	return i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.New {
		dAtA[i] = 0x8
		i++
		if m.New {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Register(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Register(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRegister(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *State) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRegister(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRegister(uint64(m.Timestamp))
	}
	return n
}

func (m *MyState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRegister(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRegister(uint64(m.Timestamp))
	}
	if m.Extra != 0 {
		n += 1 + sovRegister(uint64(m.Extra))
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.New {
		n += 2
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovRegister(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRegister(x uint64) (n int) {
	return sovRegister(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *State) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&State{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MyState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MyState{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Extra:` + fmt.Sprintf("%v", this.Extra) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteResponse{`,
		`New:` + fmt.Sprintf("%v", this.New) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest{`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func valueToStringRegister(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegister
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegister(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegister
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MyState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MyState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MyState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegister
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			m.Extra = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Extra |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegister(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegister
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRegister(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegister
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRegister(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegister
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRegister(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRegister
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegister(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegister
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegister
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRegister
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRegister
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRegister(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRegister = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegister   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("testdata/register_golden/register.proto", fileDescriptorRegister) }

var fileDescriptorRegister = []byte{
	// 463 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x93, 0xb1, 0x6f, 0xd3, 0x40,
	0x14, 0xc6, 0x7d, 0x24, 0xa1, 0xe9, 0x2b, 0x55, 0xa3, 0x13, 0x83, 0x15, 0xa1, 0x53, 0xb1, 0x90,
	0x88, 0xaa, 0x2a, 0x29, 0x45, 0x08, 0x24, 0xa6, 0x52, 0x95, 0x8d, 0xa8, 0xb8, 0x08, 0x46, 0x74,
	0x89, 0x9f, 0x82, 0x25, 0x3b, 0x17, 0xee, 0xde, 0x15, 0xb2, 0x75, 0x64, 0xec, 0x84, 0x18, 0x3b,
	0x76, 0x64, 0xc9, 0x3f, 0xc0, 0xc4, 0xd8, 0x91, 0xb1, 0x31, 0x0b, 0x23, 0x12, 0xff, 0x00, 0xba,
	0x73, 0x28, 0xed, 0x64, 0xc4, 0xe4, 0xf7, 0xee, 0xfb, 0x7e, 0xf7, 0x9e, 0xbe, 0x93, 0xe1, 0x2e,
	0xa1, 0xa1, 0x44, 0x92, 0xec, 0x69, 0x1c, 0xa5, 0x86, 0x50, 0xbf, 0x1e, 0xa9, 0x2c, 0xc1, 0xf1,
	0x45, 0xdf, 0x9d, 0x68, 0x45, 0x8a, 0xd7, 0x12, 0x3c, 0x6c, 0xdf, 0x19, 0xa5, 0xf4, 0xc6, 0x0e,
	0xba, 0x43, 0x95, 0xf7, 0x34, 0x66, 0x72, 0xd0, 0x1b, 0x29, 0x6d, 0x73, 0xb3, 0xf8, 0x94, 0xd6,
	0xe8, 0x31, 0x34, 0x0e, 0x48, 0x12, 0xf2, 0x9b, 0xd0, 0x78, 0x29, 0x33, 0x8b, 0x21, 0x5b, 0x67,
	0x9d, 0xe5, 0xb8, 0x6c, 0xf8, 0x2d, 0x58, 0x7e, 0x91, 0xe6, 0x68, 0x48, 0xe6, 0x93, 0xf0, 0xda,
	0x3a, 0xeb, 0xd4, 0xe2, 0xbf, 0x07, 0xd1, 0x01, 0x2c, 0x3d, 0x9b, 0xfe, 0x37, 0xee, 0x98, 0xbd,
	0xf7, 0xa4, 0x65, 0x58, 0xf3, 0x4a, 0xd9, 0x44, 0xb7, 0x61, 0xf5, 0x95, 0x4e, 0x09, 0x63, 0x34,
	0x13, 0x35, 0x36, 0xc8, 0x5b, 0x50, 0xeb, 0xe3, 0x3b, 0x7f, 0x71, 0x33, 0x76, 0x65, 0xb4, 0x0a,
	0x2b, 0x31, 0xca, 0x24, 0xc6, 0xb7, 0x16, 0x0d, 0x45, 0x4b, 0xd0, 0xd8, 0xcb, 0x27, 0x34, 0xdd,
	0xfe, 0x58, 0x87, 0x66, 0xbc, 0x88, 0x82, 0x6f, 0xb8, 0x5a, 0x26, 0x7d, 0xf5, 0x7c, 0x97, 0xb7,
	0xba, 0x09, 0x1e, 0x76, 0x2f, 0x31, 0x6d, 0xf0, 0x27, 0x7e, 0xf7, 0x28, 0xe0, 0x1b, 0x50, 0x77,
	0x62, 0x85, 0xaf, 0x7e, 0x34, 0x0b, 0x19, 0xdf, 0x02, 0x70, 0x86, 0xa7, 0x96, 0xac, 0xc6, 0x2a,
	0xe2, 0xc4, 0x11, 0x3b, 0xd0, 0x72, 0x86, 0x5d, 0x6b, 0x48, 0xe5, 0x31, 0x92, 0xd5, 0xe3, 0x0a,
	0x6e, 0xcd, 0x4d, 0xfa, 0xf2, 0x2b, 0xbc, 0x88, 0xf7, 0x01, 0xac, 0xf9, 0x2b, 0x94, 0xd6, 0x38,
	0x24, 0x39, 0xc8, 0x2a, 0x27, 0x7f, 0x70, 0x93, 0xb7, 0xcb, 0x5d, 0xf7, 0x35, 0x66, 0x69, 0x5e,
	0x45, 0x1c, 0xcf, 0x42, 0xb6, 0xc5, 0xf8, 0x3d, 0x68, 0xf8, 0xfc, 0xf9, 0x25, 0xb1, 0xcd, 0x7d,
	0x7d, 0xe5, 0x5d, 0xa2, 0xa6, 0x5b, 0xf2, 0xd4, 0x8d, 0x79, 0x08, 0x2b, 0x5e, 0x5a, 0x64, 0x52,
	0x09, 0x9e, 0xfc, 0x01, 0x37, 0x01, 0xbc, 0xb4, 0x63, 0xa6, 0xe3, 0xe1, 0x15, 0xae, 0xac, 0xfd,
	0xb3, 0x46, 0xf5, 0x4f, 0xb3, 0x90, 0x75, 0x18, 0x7f, 0x04, 0x37, 0xbc, 0x7b, 0x1f, 0x75, 0x5f,
	0x25, 0xff, 0xb8, 0xe0, 0xe7, 0x59, 0xc8, 0x9e, 0x6c, 0x9e, 0xcd, 0x45, 0xf0, 0x6d, 0x2e, 0x82,
	0xf3, 0xb9, 0x60, 0x47, 0x85, 0x60, 0xa7, 0x85, 0x60, 0x5f, 0x0b, 0xc1, 0xce, 0x0a, 0xc1, 0xce,
	0x0b, 0xc1, 0x7e, 0x14, 0x22, 0xf8, 0x59, 0x08, 0x76, 0xfc, 0x5d, 0x04, 0x83, 0xeb, 0xfe, 0xd7,
	0xb8, 0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xc5, 0x12, 0xd3, 0x01, 0x70, 0x03, 0x00, 0x00,
}
