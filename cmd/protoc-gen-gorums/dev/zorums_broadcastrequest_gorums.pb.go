// Code generated by protoc-gen-gorums. DO NOT EDIT.
// versions:
// 	protoc-gen-gorums v0.7.0-devel
// 	protoc            v3.12.4
// source: zorums.proto

package dev

import (
	context "context"
	fmt "fmt"
	uuid "github.com/google/uuid"
	gorums "github.com/relab/gorums"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = gorums.EnforceVersion(7 - gorums.MinVersion)
	// Verify that the gorums runtime is sufficiently up-to-date.
	_ = gorums.EnforceVersion(gorums.MaxVersion - 7)
)

func _clientMultipartyClientHandler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	return srv.(clientServer).clientMultipartyClientHandler(ctx, in)
}

func (srv *clientServerImpl) clientMultipartyClientHandler(ctx context.Context, resp *Response) (*Response, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return resp, fmt.Errorf("no metadata")
	}
	broadcastID := ""
	val := md.Get("broadcastID")
	if val != nil && len(val) >= 1 {
		broadcastID = val[0]
	}
	if broadcastID == "" {
		return resp, fmt.Errorf("no broadcastID")
	}
	srv.respChan <- &clientResponse{
		broadcastID: broadcastID,
		data:        resp,
	}
	return resp, nil
}

func (c *Configuration) MultipartyClientHandler(ctx context.Context, in *Request) (resp *Response, err error) {
	if c.srv == nil {
		return nil, fmt.Errorf("a client server is not defined. Use configuration.RegisterClientServer() to define a client server")
	}
	if c.replySpec == nil {
		return nil, fmt.Errorf("a reply spec is not defined. Use configuration.RegisterClientServer() to define a reply spec")
	}
	broadcastID := uuid.New().String()
	cd := gorums.QuorumCallData{
		Message: in,
		Method:  "dev.ZorumsService.MultipartyClientHandler",

		BroadcastID: broadcastID,
		Sender:      gorums.BROADCASTCLIENT,
		OriginAddr:  c.listenAddr,
	}
	doneChan := make(chan protoreflect.ProtoMessage)
	c.srv.reqChan <- &clientRequest{
		broadcastID: broadcastID,
		doneChan:    doneChan,
		handler:     convertToType[*Response](c.replySpec.MultipartyClientHandler),
	}
	c.RawConfiguration.Multicast(ctx, cd, gorums.WithNoSendWaiting())
	response, ok := <-doneChan
	if !ok {
		return nil, fmt.Errorf("done channel was closed before returning a value")
	}
	return response.(*Response), err
}

func _clientMultipartyClientHandler2(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	return srv.(clientServer).clientMultipartyClientHandler2(ctx, in)
}

func (srv *clientServerImpl) clientMultipartyClientHandler2(ctx context.Context, resp *ClientResponse) (*ClientResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return resp, fmt.Errorf("no metadata")
	}
	broadcastID := ""
	val := md.Get("broadcastID")
	if val != nil && len(val) >= 1 {
		broadcastID = val[0]
	}
	if broadcastID == "" {
		return resp, fmt.Errorf("no broadcastID")
	}
	srv.respChan <- &clientResponse{
		broadcastID: broadcastID,
		data:        resp,
	}
	return resp, nil
}

func (c *Configuration) MultipartyClientHandler2(ctx context.Context, in *Request) (resp *ClientResponse, err error) {
	if c.srv == nil {
		return nil, fmt.Errorf("a client server is not defined. Use configuration.RegisterClientServer() to define a client server")
	}
	if c.replySpec == nil {
		return nil, fmt.Errorf("a reply spec is not defined. Use configuration.RegisterClientServer() to define a reply spec")
	}
	broadcastID := uuid.New().String()
	cd := gorums.QuorumCallData{
		Message: in,
		Method:  "dev.ZorumsService.MultipartyClientHandler2",

		BroadcastID: broadcastID,
		Sender:      gorums.BROADCASTCLIENT,
		OriginAddr:  c.listenAddr,
	}
	doneChan := make(chan protoreflect.ProtoMessage)
	c.srv.reqChan <- &clientRequest{
		broadcastID: broadcastID,
		doneChan:    doneChan,
		handler:     convertToType[*ClientResponse](c.replySpec.MultipartyClientHandler2),
	}
	c.RawConfiguration.Multicast(ctx, cd, gorums.WithNoSendWaiting())
	response, ok := <-doneChan
	if !ok {
		return nil, fmt.Errorf("done channel was closed before returning a value")
	}
	return response.(*ClientResponse), err
}
