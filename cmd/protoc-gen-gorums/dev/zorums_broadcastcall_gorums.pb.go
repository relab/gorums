// Code generated by protoc-gen-gorums. DO NOT EDIT.
// versions:
// 	protoc-gen-gorums v0.7.0-devel
// 	protoc            v3.12.4
// source: zorums.proto

package dev

import (
	context "context"
	fmt "fmt"
	gorums "github.com/relab/gorums"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	time "time"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = gorums.EnforceVersion(7 - gorums.MinVersion)
	// Verify that the gorums runtime is sufficiently up-to-date.
	_ = gorums.EnforceVersion(gorums.MaxVersion - 7)
)

func (srv *clientServerImpl) clientBroadcastWithClientHandler1(ctx context.Context, resp *Response, broadcastID uint64) (*Response, error) {
	err := srv.AddResponse(ctx, resp, broadcastID)
	return resp, err
}

func (c *Configuration) BroadcastWithClientHandler1(ctx context.Context, in *Request, cancelOnTimeout ...bool) (resp *Response, err error) {
	if c.srv == nil {
		return nil, fmt.Errorf("config: a client server is not defined. Use mgr.AddClientServer() to define a client server")
	}
	if c.qspec == nil {
		return nil, fmt.Errorf("a qspec is not defined")
	}
	var (
		timeout  time.Duration
		ok       bool
		response protoreflect.ProtoMessage
	)
	// use the same timeout as defined in the given context.
	// this is used for cancellation.
	deadline, ok := ctx.Deadline()
	if ok {
		timeout = deadline.Sub(time.Now())
	} else {
		timeout = 5 * time.Second
	}
	broadcastID := c.snowflake.NewBroadcastID()
	doneChan, cd := c.srv.AddRequest(broadcastID, ctx, in, gorums.ConvertToType(c.qspec.BroadcastWithClientHandler1QF), "dev.ZorumsService.BroadcastWithClientHandler1")
	c.RawConfiguration.BroadcastCall(ctx, cd, gorums.WithNoSendWaiting(), gorums.WithOriginAuthentication())
	select {
	case response, ok = <-doneChan:
	case <-ctx.Done():
		if len(cancelOnTimeout) > 0 && cancelOnTimeout[0] {
			go func() {
				bd := gorums.BroadcastCallData{
					Method:      gorums.Cancellation,
					BroadcastID: broadcastID,
				}
				cancelCtx, cancelCancel := context.WithTimeout(context.Background(), timeout)
				defer cancelCancel()
				c.RawConfiguration.BroadcastCall(cancelCtx, bd)
			}()
		}
		return nil, fmt.Errorf("context cancelled")
	}
	if !ok {
		return nil, fmt.Errorf("done channel was closed before returning a value")
	}
	resp, ok = response.(*Response)
	if !ok {
		return nil, fmt.Errorf("wrong proto format")
	}
	return resp, nil
}

func (srv *clientServerImpl) clientBroadcastWithClientHandler2(ctx context.Context, resp *Response, broadcastID uint64) (*Response, error) {
	err := srv.AddResponse(ctx, resp, broadcastID)
	return resp, err
}

func (c *Configuration) BroadcastWithClientHandler2(ctx context.Context, in *Request, cancelOnTimeout ...bool) (resp *Response, err error) {
	if c.srv == nil {
		return nil, fmt.Errorf("config: a client server is not defined. Use mgr.AddClientServer() to define a client server")
	}
	if c.qspec == nil {
		return nil, fmt.Errorf("a qspec is not defined")
	}
	var (
		timeout  time.Duration
		ok       bool
		response protoreflect.ProtoMessage
	)
	// use the same timeout as defined in the given context.
	// this is used for cancellation.
	deadline, ok := ctx.Deadline()
	if ok {
		timeout = deadline.Sub(time.Now())
	} else {
		timeout = 5 * time.Second
	}
	broadcastID := c.snowflake.NewBroadcastID()
	doneChan, cd := c.srv.AddRequest(broadcastID, ctx, in, gorums.ConvertToType(c.qspec.BroadcastWithClientHandler2QF), "dev.ZorumsService.BroadcastWithClientHandler2")
	c.RawConfiguration.BroadcastCall(ctx, cd, gorums.WithNoSendWaiting(), gorums.WithOriginAuthentication())
	select {
	case response, ok = <-doneChan:
	case <-ctx.Done():
		if len(cancelOnTimeout) > 0 && cancelOnTimeout[0] {
			go func() {
				bd := gorums.BroadcastCallData{
					Method:      gorums.Cancellation,
					BroadcastID: broadcastID,
				}
				cancelCtx, cancelCancel := context.WithTimeout(context.Background(), timeout)
				defer cancelCancel()
				c.RawConfiguration.BroadcastCall(cancelCtx, bd)
			}()
		}
		return nil, fmt.Errorf("context cancelled")
	}
	if !ok {
		return nil, fmt.Errorf("done channel was closed before returning a value")
	}
	resp, ok = response.(*Response)
	if !ok {
		return nil, fmt.Errorf("wrong proto format")
	}
	return resp, nil
}

func (srv *clientServerImpl) clientBroadcastWithClientHandlerAndBroadcastOption(ctx context.Context, resp *Response, broadcastID uint64) (*Response, error) {
	err := srv.AddResponse(ctx, resp, broadcastID)
	return resp, err
}

func (c *Configuration) BroadcastWithClientHandlerAndBroadcastOption(ctx context.Context, in *Request, cancelOnTimeout ...bool) (resp *Response, err error) {
	if c.srv == nil {
		return nil, fmt.Errorf("config: a client server is not defined. Use mgr.AddClientServer() to define a client server")
	}
	if c.qspec == nil {
		return nil, fmt.Errorf("a qspec is not defined")
	}
	var (
		timeout  time.Duration
		ok       bool
		response protoreflect.ProtoMessage
	)
	// use the same timeout as defined in the given context.
	// this is used for cancellation.
	deadline, ok := ctx.Deadline()
	if ok {
		timeout = deadline.Sub(time.Now())
	} else {
		timeout = 5 * time.Second
	}
	broadcastID := c.snowflake.NewBroadcastID()
	doneChan, cd := c.srv.AddRequest(broadcastID, ctx, in, gorums.ConvertToType(c.qspec.BroadcastWithClientHandlerAndBroadcastOptionQF), "dev.ZorumsService.BroadcastWithClientHandlerAndBroadcastOption")
	c.RawConfiguration.BroadcastCall(ctx, cd, gorums.WithNoSendWaiting(), gorums.WithOriginAuthentication())
	select {
	case response, ok = <-doneChan:
	case <-ctx.Done():
		if len(cancelOnTimeout) > 0 && cancelOnTimeout[0] {
			go func() {
				bd := gorums.BroadcastCallData{
					Method:      gorums.Cancellation,
					BroadcastID: broadcastID,
				}
				cancelCtx, cancelCancel := context.WithTimeout(context.Background(), timeout)
				defer cancelCancel()
				c.RawConfiguration.BroadcastCall(cancelCtx, bd)
			}()
		}
		return nil, fmt.Errorf("context cancelled")
	}
	if !ok {
		return nil, fmt.Errorf("done channel was closed before returning a value")
	}
	resp, ok = response.(*Response)
	if !ok {
		return nil, fmt.Errorf("wrong proto format")
	}
	return resp, nil
}
